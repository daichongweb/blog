{"meta":{"title":"Daichong's Blog","subtitle":"戴崇博客,戴崇技术博客,php技术博客,hexo博客,web技术博客","description":"戴崇博客,戴崇技术博客,php技术博客,hexo博客,web技术博客","author":"Daichongweb","url":"http://www.daichongweb.com","root":"/"},"pages":[{"title":"about","date":"2019-02-16T09:44:10.000Z","updated":"2021-09-03T05:56:57.989Z","comments":true,"path":"about/index.html","permalink":"http://www.daichongweb.com/about/index.html","excerpt":"","text":"我是谁？？？？我是一个用全栈形容不了的男人！ E-mail:daichongweb@foxmail.com，daichongweb@gmain.com 技术交流群，欢迎大家加入："},{"title":"categories","date":"2019-06-23T06:23:08.000Z","updated":"2021-09-03T05:56:57.989Z","comments":true,"path":"categories/index.html","permalink":"http://www.daichongweb.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-09-03T05:56:57.990Z","updated":"2021-09-03T05:56:57.990Z","comments":true,"path":"friends/index.html","permalink":"http://www.daichongweb.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-23T06:22:55.000Z","updated":"2021-09-03T05:56:58.004Z","comments":true,"path":"tags/index.html","permalink":"http://www.daichongweb.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"解决微信小程序授权第一次总是会失败的问题","slug":"解决微信小程序授权第一次总是会失败的问题","date":"2021-04-20T02:52:42.000Z","updated":"2021-09-03T05:56:57.987Z","comments":true,"path":"解决微信小程序授权第一次总是会失败的问题/","link":"","permalink":"http://www.daichongweb.com/解决微信小程序授权第一次总是会失败的问题/","excerpt":"介绍&emsp;相信有很多同学都遇到过小程序需要授权两次的问题，这个问题的原因是错误的授权流程导致的。 &emsp;(1)错误的流程：引导用户点击授权按钮(getUserProfile)=&gt;调起授权(wx.getUserProfile)=&gt;获取code(wx.login)=&gt;请求后端、传输数据（code、iv等）=&gt;后端解密并登陆。 &emsp;(2)正确的流程：获取code(wx.show)=&gt;引导用户点击授权按钮(getUserProfile)=&gt;调起授权(wx.getUserProfile)=&gt;请求后端、传输数据（code、iv等）=&gt;后端解密并登陆。","text":"介绍&emsp;相信有很多同学都遇到过小程序需要授权两次的问题，这个问题的原因是错误的授权流程导致的。 &emsp;(1)错误的流程：引导用户点击授权按钮(getUserProfile)=&gt;调起授权(wx.getUserProfile)=&gt;获取code(wx.login)=&gt;请求后端、传输数据（code、iv等）=&gt;后端解密并登陆。 &emsp;(2)正确的流程：获取code(wx.show)=&gt;引导用户点击授权按钮(getUserProfile)=&gt;调起授权(wx.getUserProfile)=&gt;请求后端、传输数据（code、iv等）=&gt;后端解密并登陆。 代码演示(1)错误的流程123456789101112131415161718192021222324252627282930getUserProfile: function (e) &#123; let _this = this; // 微信小程序授权框 wx.getUserProfile(&#123; desc: '用于完善会员资料', success: (userResult) =&gt; &#123; wx.login(&#123; success (loginResult) &#123; if (loginResult.code) &#123; //发起网络请求,数据解密 wx.request(&#123; url: 'https://test.com/onLogin', data: &#123; code: loginResult.code, iv: userResult.iv, encryptedData: userResult.encryptedData, rawData: userResult.rawData &#125;, success(res)&#123; // 解密成功，并登陆 &#125; &#125;) &#125; else &#123; console.log('登录失败！' + res.errMsg) &#125; &#125; &#125;) &#125; &#125;)&#125; (2)正确的流程12345678910111213141516171819202122232425262728293031323334353637383940414243// 获取codeonShow:function()&#123; wx.login(&#123; success: res =&gt; &#123; _this.setData(&#123; code: res.code &#125;) &#125; &#125;);&#125;// 用户点击了授权按钮getUserProfile: function (e) &#123; let _this = this; // 检测授权是否过期 wx.checkSession(&#123; success(checkRes) &#123; // 调起授权窗口 wx.getUserProfile(&#123; lang: 'zh_CN', desc: '用于完善会员资料', success: (userResult) =&gt; &#123; //发起网络请求,数据解密 wx.request(&#123; url: 'https://test.com/onLogin', data: &#123; code: _this.data.code, iv: userResult.iv, encryptedData: userResult.encryptedData, rawData: userResult.rawData &#125;, success(res)&#123; //解密成功，并登陆 &#125; &#125;) &#125; &#125;) &#125;, fail() &#123; //过期重新获取 _this.getCode(); &#125; &#125;) &#125;, 注意&emsp;正确的写法在微信开发者工具和扫码预览都无法调起微信授权框，一定要在真机调试和发布体验版中测试。","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://www.daichongweb.com/tags/微信小程序/"}]},{"title":"php微信支付ApiV3版-新版微信支付开发","slug":"php微信支付ApiV3版-新版微信支付开发","date":"2021-04-06T08:13:10.000Z","updated":"2021-09-03T05:56:57.956Z","comments":true,"path":"php微信支付ApiV3版-新版微信支付开发/","link":"","permalink":"http://www.daichongweb.com/php微信支付ApiV3版-新版微信支付开发/","excerpt":"微信支付文档统一下单文档JsApi 前期准备流程 微信公众号申请 支付商户号申请 微信公众号绑定支付商户号","text":"微信支付文档统一下单文档JsApi 前期准备流程 微信公众号申请 支付商户号申请 微信公众号绑定支付商户号 4.设置白名单、生成AppSecret（开发-基本配置） 5.申请Api证书、设置APIv3密钥 6.设置支付配置、jsapi支付授权目录、Native支付回调链接（产品中心-开发配置） 支付流程 1.前端调用后端下单接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 创建订单 * @param &#123;*&#125; active * @param &#123;*&#125; mobile * @param &#123;*&#125; token */function createOrder(active, mobile, token) &#123; $.showLoading(); $.ajax(&#123; type: 'post', url: url, data: &#123; 'active': active, 'pay_type': 'wechat', 'mobile': mobile &#125;, dataType: 'json', beforeSend: function (XMLHttpRequest) &#123; XMLHttpRequest.setRequestHeader(\"token\", token); &#125;, success: function (res) &#123; try &#123; if (res.status == 'error' || res.code != 200) &#123; $.toptip(res.message, 'warning') return false; &#125; WeixinJSBridge.invoke('getBrandWCPayRequest', &#123; \"appId\": res.data.appId, \"timeStamp\": res.data.timeStamp, \"nonceStr\": res.data.nonceStr, \"package\": res.data.package, \"signType\": res.data.signType, \"paySign\": res.data.paySign &#125;, function (res) &#123; if (res.err_msg == \"get_brand_wcpay_request:ok\") &#123; $.toptip('支付成功', 'success') &#125; &#125;); &#125; catch (err) &#123; toLogin(); &#125; &#125;, error: function (res) &#123; $.toptip('网络错误', 'warning') &#125;, complete: function (res) &#123; $.hideLoading(); &#125; &#125;)&#125;&lt;a href=\"javascript:;\" class=\"weui-btn weui-btn_primary\" onclick=\"createOrder(1,mobile,token)\"&gt;立即支付&lt;/a&gt; 2.处理信息、生成订单、返回支付信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * 生成订单 * @param $userId * @param $mobile * @param int $active * @param string $payType * @return array|mixed * @throws ApiException * @throws \\Throwable */ public function createOrder($userId, $mobile, $active = 1, $payType = 'wechat') &#123; DB::beginTransaction(); try &#123; if ($this-&gt;countWaitOrderByUserId($userId)) &#123; throw new ApiException('您有未支付的订单，请先处理完毕', 500); &#125; $activity = $this-&gt;findActive($active); if (!$activity) &#123; throw new ApiException('充值金额有误', 500); &#125; $orderId = StringHelper::getOrderId('R'); $orderData = [ 'order_id' =&gt; $orderId, 'user_id' =&gt; $userId, 'original_price' =&gt; $activity-&gt;original_price, 'price' =&gt; $activity-&gt;price, 'pay_type' =&gt; $payType, 'mobile' =&gt; $mobile, 'active' =&gt; $active ]; if (!$this-&gt;insertOrder($orderData)) &#123; throw new ApiException('订单创建失败', 500); &#125; // 请求微信统一下单 if ($result = $this-&gt;payOrder($orderId, $userId)) &#123; DB::commit(); return $result; &#125; throw new ApiException('统一下单失败', 500); &#125; catch (\\Exception $exception) &#123; DB::rollBack(); throw new ApiException($exception-&gt;getMessage(), 500); &#125; &#125; /** * 微信统一下单 * @param $orderId * @param $userId * @return mixed * @throws ApiException * @throws GuzzleException */ public function payOrder($orderId, $userId) &#123; $orderInfo = $this-&gt;findOrderByOrderId($orderId); if (!$orderInfo || $orderInfo-&gt;user_id != $userId) &#123; throw new ApiException('订单不存在', 500); &#125; $userInfo = (new UserService())-&gt;findUserById($userId, ['openid']); if (!$userInfo) &#123; throw new ApiException('用户不存在', 500); &#125; if (!$userInfo-&gt;openid) &#123; throw new ApiException('请先绑定微信', 500); &#125; $payParam = config('wechat.config'); //统一下单参数 $payConfig = [ 'appid' =&gt; $payParam['appId'], 'mchid' =&gt; $payParam['mchId'], 'description' =&gt; $orderInfo['price'] . '话费充值-话费慢充72小时内到账', 'out_trade_no' =&gt; $orderId, 'notify_url' =&gt; $payParam['notifyUrl'], 'amount' =&gt; [ 'total' =&gt; $orderInfo['price'], 'currency' =&gt; 'CNY' ], 'payer' =&gt; [ 'openid' =&gt; $userInfo['openid'] ] ]; // 重点，微信apiv3必须在headers里设置四个参数 $client = new Client(); $httpClient = $client-&gt;post($payParam['payUrl'], [ 'headers' =&gt; [ 'Content-Type' =&gt; 'application/json', 'User-Agent' =&gt; 'Mozilla/4.0', 'Accept' =&gt; 'application/json', 'Authorization' =&gt; StringHelper::getAuth($payParam['payUrl'], json_encode($payConfig), 'POST') ], 'json' =&gt; $payConfig ]); $result = $httpClient-&gt;getBody() -&gt;getContents(); $payResult = json_decode($result, true); if ($httpClient-&gt;getStatusCode() != 200) &#123; throw new ApiException('支付错误', 500); &#125; if (isset($payResult['errcode'])) &#123; throw new ApiException($payResult['errmsg'], 500); &#125; if (isset($payResult['code'])) &#123; throw new ApiException($payResult['code'], 500); &#125; // 获取支付参数 $appId = $payParam['appId']; $time = time(); $str = StringHelper::createNonce(); $prepayId = 'prepay_id=' . $payResult['prepay_id']; $message = $appId . \"\\n\" . $time . \"\\n\" . $str . \"\\n\" . $prepayId . \"\\n\"; return [ 'appId' =&gt; $payParam['appId'], 'timeStamp' =&gt; $time, 'nonceStr' =&gt; $str, 'package' =&gt; 'prepay_id=' . $payResult['prepay_id'], 'signType' =&gt; 'RSA', 'paySign' =&gt; StringHelper::getSign($message) ]; &#125; // 生成字符串 public static function createNonce($length = 32) &#123; $chars = \"abcdefghijklmnopqrstuvwxyz0123456789\"; $str = \"\"; for ($i = 0; $i &lt; $length; $i++) &#123; $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1); &#125; return $str; &#125; // 生成auth public static function getAuth($url, $body, $type = 'POST') &#123; $config = Config::get('wechat.config'); $nonce = self::createNonce(); $timestamp = time(); $url_parts = parse_url($url); $canonical_url = ($url_parts['path'] . (!empty($url_parts['query']) ? \"?$&#123;url_parts['query']&#125;\" : \"\")); $message = $type . \"\\n\" . $canonical_url . \"\\n\" . $timestamp . \"\\n\" . $nonce . \"\\n\" . $body . \"\\n\"; $sign = self::getSign($message); $schema = 'WECHATPAY2-SHA256-RSA2048'; $token = sprintf('mchid=\"%s\",nonce_str=\"%s\",timestamp=\"%d\",serial_no=\"%s\",signature=\"%s\"', $config['mchId'], $nonce, $timestamp, $config['serialNo'], $sign); return $schema . ' ' . $token; &#125; // 获取证书 public static function getSign($message) &#123; $filePath = '../resources/cert/apiclient_key.pem'; openssl_sign($message, $raw_sign, openssl_get_privatekey(file_get_contents($filePath)), 'sha256WithRSAEncryption'); return base64_encode($raw_sign); &#125; 完成支付这篇文章没有使用微信的sdk，所以代码量还有有点大的，不过整体逻辑简单。","categories":[],"tags":[{"name":"微信支付","slug":"微信支付","permalink":"http://www.daichongweb.com/tags/微信支付/"}]},{"title":"JetBrains2020全家桶激活","slug":"JetBrains2020全家桶激活","date":"2020-08-19T02:28:42.000Z","updated":"2021-09-03T05:56:57.858Z","comments":true,"path":"JetBrains2020全家桶激活/","link":"","permalink":"http://www.daichongweb.com/JetBrains2020全家桶激活/","excerpt":"官方下载最新版JetBrains官网下载 亲测可激活 1.IntelliJ IDEA 2020.2及以下版本2.PhpStorm 2020.2及以下版本3.WebStorm 2020.2及以下版本","text":"官方下载最新版JetBrains官网下载 亲测可激活 1.IntelliJ IDEA 2020.2及以下版本2.PhpStorm 2020.2及以下版本3.WebStorm 2020.2及以下版本 下载补丁下载补丁 如何激活&emsp;(1).运行IDE（新安装的选择Evaluate） &emsp;(2).随便打开或者创建一个项目，成功后保持不动 &emsp;(3).把补丁解压后的jetbrains-agent.jar拖入到IDE中，弹框后点击Restart。 &emsp;(4).重启后会弹出【JetbrainsAgent 配置助手】，选择Activation Code，复制下面的安装参数，然后点击为XXX安装就可以了！！！ 安装参数1LFq51qqupnaiTNn39w6zATiOTxZI2JYuRJEBlzmUDv4zeeNlXhMgJZVb0q5QkLr+CIUrSuNB7ucifrGXawLB4qswPOXYG7+ItDNUR/9UkLTUWlnHLX07hnR1USOrWIjTmbytcIKEdaI6x0RskyotuItj84xxoSBP/iRBW2EHpOc 常见问题&emsp;(1).安装成功后还是跳转到激活页面，请尝试断网后再操作。&emsp;(2).断网后还是无法破解，请尝试删除hosts设置的映射后再操作。 致谢🙏&emsp;好用的话就请评论一下再走吧！","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://www.daichongweb.com/tags/开发工具/"}]},{"title":"fastjson类型转换","slug":"fastjson类型转换","date":"2020-05-25T03:15:32.000Z","updated":"2021-09-03T05:56:57.912Z","comments":true,"path":"fastjson类型转换/","link":"","permalink":"http://www.daichongweb.com/fastjson类型转换/","excerpt":"jsonString转map1JSON.parseObject(string) 实体类转jsonstring1JSON.toJSONString(javaClass)","text":"jsonString转map1JSON.parseObject(string) 实体类转jsonstring1JSON.toJSONString(javaClass) 存入redis队列之前是jsonString，拿出来变成object处理办法1234// 先转字符String value = lotteryData.index(roomId, userId).toString();// 转mapJSON.parseObject(value); 如何组成一个多维数组12345678910111213141516171819202122232425262728293031// 例子&#123; \"data\": [ &#123; \"nickname\": \"戴崇\", \"userId\": 6144, \"roomId\": 10086 &#125;, &#123; \"nickname\": \"戴崇\", \"userId\": 2174, \"roomId\": 10086 &#125;, &#123; \"nickname\": \"戴崇\", \"userId\": 9997, \"roomId\": 10086 &#125; ], \"code\": \"0\", \"msg\": \"操作成功！\"&#125;// 做法List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();for (long userId : rands) &#123; if (userId == 0) &#123; continue; &#125; String value = lotteryData.index(roomId, userId).toString(); list.add(JSON.parseObject(value));&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.daichongweb.com/tags/java/"}]},{"title":"mac下使用homebrew安装指定版本node","slug":"mac下使用homebrew安装指定版本node","date":"2020-05-10T11:21:41.000Z","updated":"2021-09-03T05:56:57.931Z","comments":true,"path":"mac下使用homebrew安装指定版本node/","link":"","permalink":"http://www.daichongweb.com/mac下使用homebrew安装指定版本node/","excerpt":"介绍&emsp;mac下的homebrew直接使用brew install node安装的node版本是14.+，这给很多程序带来了问题，如果直接安装低版本的node会造成‘npm’等无法使用。 卸载1brew remove node","text":"介绍&emsp;mac下的homebrew直接使用brew install node安装的node版本是14.+，这给很多程序带来了问题，如果直接安装低版本的node会造成‘npm’等无法使用。 卸载1brew remove node 解绑&emsp;卸载之后要先把之前node解除连接。1brew unlink node 查找可用的node版本1brew search node 安装1brew install node@10 添加环境变量12vi ~/.bash_profileexport PATH=\"/usr/local/opt/node@10/bin:$PATH\" &emsp;经过此步骤还是无法在终端使用‘node -v’就增加12vi ~/.bash_profilealias node='/usr/local/opt/node@10/bin/node' &emsp;无法使用npm等情况执行1brew link --overwrite --force node@10","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://www.daichongweb.com/tags/node/"}]},{"title":"php生成海报图出现图片损坏的问题","slug":"php生成海报图出现图片损坏的问题","date":"2020-05-10T08:52:30.000Z","updated":"2021-09-03T05:56:57.961Z","comments":true,"path":"php生成海报图出现图片损坏的问题/","link":"","permalink":"http://www.daichongweb.com/php生成海报图出现图片损坏的问题/","excerpt":"简介&emsp;近年小程序、微信发展迅速。微信、微博病毒式传播使用户从传统的APP上向即扫即用、无需安装的小程序上转化。而微信公众号、小程序的迅速发展离不开转发、二维码分享。 &emsp;但是二维码形式单一，对用户来说毫无吸引力。纯粹依靠‘吆喝、金钱、礼物吸引’方式已经变得愈来愈无价值。 &emsp;对于’视觉动物’和大部分用户来说，精美的图片加上二维码的组合更具有吸引力。","text":"简介&emsp;近年小程序、微信发展迅速。微信、微博病毒式传播使用户从传统的APP上向即扫即用、无需安装的小程序上转化。而微信公众号、小程序的迅速发展离不开转发、二维码分享。 &emsp;但是二维码形式单一，对用户来说毫无吸引力。纯粹依靠‘吆喝、金钱、礼物吸引’方式已经变得愈来愈无价值。 &emsp;对于’视觉动物’和大部分用户来说，精美的图片加上二维码的组合更具有吸引力。 php生成海报图前提条件 gd库扩展 上代码生成方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 生成方法private function createPoster($data) &#123; $poster = new Poster(); //创建画布 $im = $poster-&gt;createTrueColor(672, 1060); //字体文件 $font_file = $this-&gt;typeface; // 商品图片 $goodsImg = $poster-&gt;createImgBoard($im, $data['goodsPath'], 0, 0, 672, 668); //二维码 $codeImg = $poster-&gt;createImgBoard($im, $data['qrcode'], 410, 710, 225, 225); //headimg $headImg = $poster-&gt;createImgBoard($im, $data['headimg'], 46, 942, 65, 65); //btnimg $btnimg = $poster-&gt;createImgBoard($im, $data['btn'], 420, 960, 220, 48); // 价格 $price_font = ImageColorAllocate($im, 248, 6, 74); imagettftext($im, 25, 0, 41, 759, $price_font, $font_file, '¥'); imagettftext($im, 38, 0, 60, 760, $price_font, $font_file, $data[\"price\"]); // 商品名称 $goodsName = trim(mb_substr($data['title'], 0, 20)); $good_font = ImageColorAllocate($im, 1, 1, 1); imagettftext($im, 24, 0, 40, 820, $good_font, $font_file, $poster-&gt;AutoWrap(12, 0, $font_file, $goodsName, 160)); // 昵称 $nickname = trim(mb_substr($data['nickname'], 0, 8)); $nick_font = ImageColorAllocate($im, 109, 114, 120); imagettftext($im, 16, 0, 130, 965, $nick_font, $font_file, $poster-&gt;AutoWrap(12, 0, $font_file, $nickname, 80)); imagettftext($im, 16, 0, 130, 1000, $nick_font, $font_file, $data['time']); ob_clean(); ob_end_clean(); // 输出图片 $poster-&gt;lookImg($im); //释放空间 imagedestroy($im); imagedestroy($btnimg); imagedestroy($goodsImg); imagedestroy($codeImg); imagedestroy($headImg); // 删除本地二维码 Qrcode::deleteCode($data['qrcode']); &#125; 实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// 具体类&lt;?phpnamespace app\\library;/** * 生成海报图 * @author daichongweb * @url daichongweb.cn,daichongweb.com */class Poster&#123; /** * 从图片文件创建Image资源 * @param $file 图片文件，支持url * @return bool|resource 成功返回图片image资源，失败返回false */ public function createImageFromFile($file) &#123; if (preg_match('/http(s)?:\\/\\//', $file)) &#123; $fileSuffix = self::getNetworkImgType($file); &#125; else &#123; $file_info = getimagesize($file); $fileSuffix = $file_info[2]; // $fileSuffix = pathinfo($file, PATHINFO_EXTENSION); &#125; if (!$fileSuffix) return false; switch ($fileSuffix) &#123; /*case 'jpeg': $theImage = @imagecreatefromjpeg($file); break;*/ case '2': $theImage = imagecreatefromjpeg($file); break; case '3': $theImage = @imagecreatefrompng($file); break; case '1': $theImage = @imagecreatefromgif($file); break; default: $theImage = @imagecreatefromstring(file_get_contents($file)); break; &#125; return $theImage; &#125; // 文字换行 public function AutoWrap($fontsize, $angle, $fontface, $string, $width) &#123; $content = \"\"; for ($i = 0; $i &lt; mb_strlen($string); $i++) &#123; $letter[] = mb_substr($string, $i, 1); &#125; foreach ($letter as $l) &#123; $teststr = $content . \"\" . $l; $testbox = imagettfbbox($fontsize, $angle, $fontface, $teststr); if (($testbox[2] &gt; $width) &amp;&amp; ($content !== \"\")) &#123; $content .= \"\\n\"; &#125; $content .= $l; &#125; $content = mb_convert_encoding($content, \"html-entities\", \"utf-8\"); return $content; &#125; public function getNetworkImgType($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_NOBODY, 1); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 3); curl_setopt($ch, CURLOPT_TIMEOUT, 3); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_exec($ch); $http_code = curl_getinfo($ch); curl_close($ch); if ($http_code['http_code'] == 200) &#123; $theImgType = explode('/', $http_code['content_type']); if ($theImgType[0] == 'image') &#123; return $theImgType[1]; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; /** * 创建真彩画布 * @param int $width * @param int $height * @param int $r * @param int $g * @param int $b * @return false|resource */ public function createTrueColor(int $width, int $height, $r = 255, $g = 255, $b = 255) &#123; $im = imagecreatetruecolor($width, $height); $color = imagecolorallocate($im, $r, $g, $b); imagefill($im, 0, 0, $color); return $im; &#125; /** * 创建图像画布 * @param $im * @param $imgUrl * @param $dst_w * @param $dst_h * @return bool|resource */ public function createImgBoard($im, $imgUrl, $dst_x, $dst_y, $dst_w, $dst_h) &#123; list($width, $height) = getimagesize($imgUrl); $imgBoard = Poster::createImageFromFile($imgUrl); imagecopyresized($im, $imgBoard, $dst_x, $dst_y, 0, 0, $dst_w, $dst_h, $width, $height); return $imgBoard; &#125; /** * @param $im */ public function lookImg($im) &#123; header(\"Content-type:text/html;charset=utf-8\"); Header(\"Content-Type: image/jpeg\"); // jpeg 生成会更快，png生成速度慢但是高清 imagejpeg($im); &#125;&#125; 使用方法123456789101112131415161718192021222324// 获取微信二维码$codePath = Qrcode::createQrcode([ 'scene' =&gt; $scene, 'page' =&gt; $path, 'width' =&gt; '112', 'auto_color' =&gt; false, 'line_color' =&gt; [ 'r' =&gt; 0, 'g' =&gt; 0, 'b' =&gt; 0 ]]);$data = [ 'bg' =&gt; $this-&gt;bg, 'goodsPath' =&gt; $goodsPath, 'title' =&gt; $goodsName, 'price' =&gt; $goodsPrice, 'btn' =&gt; $this-&gt;btn, 'time' =&gt; date('Y-m-d H:i'), 'qrcode' =&gt; $codePath, 'headimg' =&gt; $userInfo-&gt;headimgurl ? $userInfo-&gt;headimgurl : $this-&gt;defaultHeadImg, 'nickname' =&gt; $userInfo-&gt;nickname ? $userInfo-&gt;nickname : '特抱抱'];$this-&gt;createPoster($data); 效果图 &emsp;从上面两个图很明显可以看出，第二张图下面被切掉了，而且电脑是打不开的。解决这个问题的关键在于ob_clean();ob_end_clean();两个函数。 解决方法123// 清空缓冲区ob_clean();ob_end_clean();","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"微信小程序支付","slug":"微信小程序支付","date":"2020-05-10T06:57:38.000Z","updated":"2021-09-03T05:56:57.977Z","comments":true,"path":"微信小程序支付/","link":"","permalink":"http://www.daichongweb.com/微信小程序支付/","excerpt":"小程序支付&emsp;现如今的小程序愈发重要，微信小程序开发也成为开发者必须掌握的重要的技能之一。&emsp;经过多年的发展，小程序开发更新换代非常快，在最近的开发中发现之前小程序支付的写法已经完全不适用了，害得我研究了很久，特写一篇文章记录一下。 开发前提&emsp;（1）开通微信支付商户号。&emsp;（2）开通小程序。&emsp;（3）微信支付平台设置特约商户APPID,绑定小程序Appid。（这里要注意，小程序和支付商户必须是同一个主体）。&emsp;（4）小程序绑定微信支付商户号。","text":"小程序支付&emsp;现如今的小程序愈发重要，微信小程序开发也成为开发者必须掌握的重要的技能之一。&emsp;经过多年的发展，小程序开发更新换代非常快，在最近的开发中发现之前小程序支付的写法已经完全不适用了，害得我研究了很久，特写一篇文章记录一下。 开发前提&emsp;（1）开通微信支付商户号。&emsp;（2）开通小程序。&emsp;（3）微信支付平台设置特约商户APPID,绑定小程序Appid。（这里要注意，小程序和支付商户必须是同一个主体）。&emsp;（4）小程序绑定微信支付商户号。 具体差别&emsp;可以从很久之前的文章看出，现在的小程序支付多了一个二次签名的步骤，这点需要大家注意。&emsp;其他的步骤倒是没什么差别，具体可 官方文档。 上代码（废话不多说，yii2写法）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public function actionIndex()&#123; try &#123; $user_id = FsRequest::userId('true'); if (!$user_id) &#123; throw new Exception('请先登录', [], 201); &#125; $data = \\Yii::$app-&gt;request-&gt;post(); if (empty($data)) &#123; throw new Exception('参数不全', [], 201); &#125; $openId = WeixinUser::find()-&gt;where(['ecuid' =&gt; $user_id])-&gt;select(['dingdang_mini'])-&gt;one(); if (!$openId) &#123; throw new Exception('未绑定小程序', [], 201); &#125; $payParams = [ 'appid' =&gt; $appid, 'mch_id' =&gt; $mch_id, 'nonce_str' =&gt; WxHelper::createNoncestr(32), 'sign' =&gt; '', 'body' =&gt; $data['body'], 'out_trade_no' =&gt; $data['orderId'], 'total_fee' =&gt; (int)($data['price'] * 100), 'openid' =&gt; $openId-&gt;dingdang_mini, 'spbill_create_ip' =&gt; $_SERVER['REMOTE_ADDR'], 'notify_url' =&gt; '支付回调', 'trade_type' =&gt; 'JSAPI', ]; $payParams['sign'] = WxHelper::paySign($payParams, $key); $xml = WxHelper::arrayToXml($payParams); // die($xml); $payUrl = 'https://api.mch.weixin.qq.com/pay/unifiedorder'; $curl = new Curl(); $curl-&gt;setHeader('Content-Type', 'text/xml; charset=utf-8'); // xml $curl-&gt;post($payUrl, $xml); // 请求失败 if ($curl-&gt;error) &#123; throw new Exception($curl-&gt;errorMessage, [], 201); &#125; else &#123; // 微信返回错误 $result = WxHelper::xmlToArray($curl-&gt;response); if ($result['result_code'] == 'FAIL') &#123; throw new Exception($result['err_code_des'], [], 201); &#125; // 二次签名 $payParamsResult = [ 'appId' =&gt; $this-&gt;appid, 'nonceStr' =&gt; WxHelper::createNoncestr(32), 'package' =&gt; 'prepay_id=' . $result['prepay_id'], 'paySign' =&gt; '', 'signType' =&gt; 'MD5', 'timeStamp' =&gt; (string)time() ]; $payParamsResult['paySign'] = WxHelper::paySign($payParamsResult, $this-&gt;key); FsResponse::jsonSuccess($payParamsResult); &#125; &#125; catch (Exception $e) &#123; return FsResponse::jsonFaild($e-&gt;getCode(), $e-&gt;getMessage()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?php// 具体方法namespace app\\library\\wechat;use \\Curl\\Curl;use app\\models\\redis\\WxAccessToken;use yii\\db\\Exception;/** * Class WxHelper * @package app\\library */class WxHelper&#123; // 获取小程序AccessToken public static function getToken() &#123; $token = WxAccessToken::get(); if (!$token) &#123; $url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=' . $appId . '&amp;secret=' . $secret; $curl = new Curl(); $curl-&gt;get($url); if ($curl-&gt;error) &#123; WxAccessToken::delete(); throw new Exception($curl-&gt;errorMessage, [],210); &#125; if (isset($curl-&gt;response-&gt;errcode)) &#123; WxAccessToken::delete(); throw new Exception($curl-&gt;response-&gt;errmsg,[],210); &#125; $token = $curl-&gt;response-&gt;access_token; $time = $curl-&gt;response-&gt;expires_in; WxAccessToken::set($token, $time - 100); &#125; return $token; &#125; public static function xmlToArray($xml) &#123; //禁止引用外部xml实体 libxml_disable_entity_loader(true); $values = json_decode(json_encode(simplexml_load_string($xml, 'SimpleXMLElement', LIBXML_NOCDATA)), true); return $values; &#125; public static function paySign($payParams, $key) &#123; ksort($payParams); $signString = self::toUrlParams($payParams); $signString .= '&amp;key=' . $key; $signString = strtoupper(md5($signString)); return $signString; &#125; #生成随机字符串 public static function createNoncestr($length = 7) &#123; $chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ0123456789\"; $str = \"\"; for ($i = 0; $i &lt; $length; $i++) &#123; $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1); &#125; return $str; &#125; public static function toUrlParams($payParams) &#123; $buff = \"\"; foreach ($payParams as $k =&gt; $v) &#123; if ($k != \"sign\" &amp;&amp; $v != \"\" &amp;&amp; !is_array($v)) &#123; $buff .= $k . \"=\" . $v . \"&amp;\"; &#125; &#125; $buff = trim($buff, \"&amp;\"); return $buff; &#125; public static function arrayToXml($array) &#123; $xml = \"&lt;xml&gt;\"; foreach ($array as $key =&gt; $val) &#123; if (is_numeric($val)) &#123; $xml .= \"&lt;\" . $key . \"&gt;\" . $val . \"&lt;/\" . $key . \"&gt;\"; &#125; else &#123; $xml .= \"&lt;\" . $key . \"&gt;&lt;![CDATA[\" . $val . \"]]&gt;&lt;/\" . $key . \"&gt;\"; &#125; &#125; $xml .= \"&lt;/xml&gt;\"; return $xml; &#125;&#125; 总结&emsp;微信支付比较简单，只是文档写的不清晰导致开发难度增加。","categories":[],"tags":[{"name":"小程序支付","slug":"小程序支付","permalink":"http://www.daichongweb.com/tags/小程序支付/"}]},{"title":"phpOffice/phpSpreadsheet导出excel","slug":"phpOffice-phpSpreadsheet导出excel","date":"2020-04-10T01:46:38.000Z","updated":"2021-09-03T05:56:57.944Z","comments":true,"path":"phpOffice-phpSpreadsheet导出excel/","link":"","permalink":"http://www.daichongweb.com/phpOffice-phpSpreadsheet导出excel/","excerpt":"初识phpSpreadsheet&emsp;PHPSpreadsheet是由老外使用纯PHP编写的Excel文件处理扩展，他使用的是最新写法，相比PHPExcel(已不再维护)性能提升巨大，使用方法和函数基本相同，可以完全的替代PHPExcel。使用PhpSpreadsheet可以轻松读取和写入Excel文档，支持Excel的所有操作。 软件依赖 PHP5.6或更高版本，推荐PHP7 php_zip扩展 php_gd2扩展","text":"初识phpSpreadsheet&emsp;PHPSpreadsheet是由老外使用纯PHP编写的Excel文件处理扩展，他使用的是最新写法，相比PHPExcel(已不再维护)性能提升巨大，使用方法和函数基本相同，可以完全的替代PHPExcel。使用PhpSpreadsheet可以轻松读取和写入Excel文档，支持Excel的所有操作。 软件依赖 PHP5.6或更高版本，推荐PHP7 php_zip扩展 php_gd2扩展 PHPSpreadsheet 特性 支持导入和导出.xls，.xlsx，.html，.csv，.pdf等格式文件。 提供丰富的API，提供单元格样式设置、Excel表格属性设置、图表设置等等诸多功能。使用PhpSpreadsheet完全可以生成一个外观结构都满足你的Excel表格文件。 卓越的性能，尤其在PHP7上表现优异，比PHPExcel强大很多。 安装1composer require phpoffice/phpspreadsheet 实战&emsp;下面咱们来做一个通用的导出Excel表格类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;?phpnamespace app\\common\\library;use app\\common\\exception\\BusiException;use PhpOffice\\PhpSpreadsheet\\IOFactory;use PhpOffice\\PhpSpreadsheet\\Spreadsheet;/** * 导出excel class * @author daichongweb */class Export&#123; // 表格坐标 private $cellIndex = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'AA', 'AB', 'AC', 'AD', 'AE', 'AF', 'AG', 'AH', 'AI', 'AJ', 'AK', 'AL', 'AM', 'AN', 'AO', 'AP', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AV', 'AW', 'AX', 'AY', 'AZ']; // 默认配置 public $config = [ 'bold' =&gt; true, // 加粗 'size' =&gt; 12, // 文字大小 'column' =&gt; 4, // 设置列数 'title' =&gt; '默认导出', // 表格标题 'name' =&gt; '特抱抱', // 文件名 'type' =&gt; 'Xls', // 导出格式 ]; // 默认表头 public $tableHeader = [ 'php', 'vue', 'java', 'go', ]; // 默认数据 public $tableDefaultData = [ [ '天下第一', 'Vue牛逼', 'java牛逼', 'go牛逼', ], ]; /** * @param array $tableHeader 表头 * @param array $tableDefaultData 需要导出数据 */ public function __construct($tableHeader, $tableDefaultData) &#123; if (empty($tableHeader)) &#123; throw new BusiException('export error', '请设置表头'); &#125; if (empty($tableDefaultData)) &#123; throw new BusiException('export error', '请设置导出数据'); &#125; $this-&gt;tableHeader = $tableHeader; $this-&gt;config['column'] = count($tableHeader); $this-&gt;tableDefaultData = $tableDefaultData; &#125; /** * 创建表格 createTable */ public function createTable() &#123; $spreadsheet = new Spreadsheet(); $worksheet = $spreadsheet-&gt;getActiveSheet(); //居中 $styleArray = [ 'alignment' =&gt; [ 'horizontal' =&gt; \\PhpOffice\\PhpSpreadsheet\\Style\\Alignment::HORIZONTAL_CENTER, ], ]; // 设置基本属性 $worksheet-&gt;setTitle($this-&gt;config['title']); $worksheet-&gt;getStyle($this-&gt;getColumn())-&gt;applyFromArray($styleArray) -&gt;getFont() -&gt;setBold($this-&gt;config['bold']) -&gt;setName('Verdana') -&gt;setSize($this-&gt;config['size']); foreach ($this-&gt;tableHeader as $index =&gt; $name) &#123; $worksheet-&gt;setCellValue($this-&gt;cellIndex[$index] . '1', $name); &#125; $baseRow = 2; foreach ($this-&gt;tableDefaultData as $index =&gt; $data) &#123; $i = $index + $baseRow; for ($k = 0; $k &lt;= $this-&gt;config['column'] - 1; $k++) &#123; $item = $data[$k]; $worksheet-&gt;setCellValue($this-&gt;cellIndex[$k] . $i, ' ' . $item); // 中文设置表格宽度 if (preg_match(\"/[\\x7f-\\xff]/\", $data[$k])) &#123; $worksheet-&gt;getColumnDimension($this-&gt;cellIndex[$k])-&gt;setWidth(strlen($item)); &#125; else &#123; // 非中文自动设置宽度 $worksheet-&gt;getColumnDimension($this-&gt;cellIndex[$k])-&gt;setAutoSize(true); &#125; &#125; &#125; $worksheet-&gt;calculateColumnWidths(); self::downloadExcel($spreadsheet, $this-&gt;config['name'], 'Xls'); &#125; /** * 文件下载 downloadExcel * * @param data $spreadsheet * @param string $filename * @param string $format * @return void */ private function downloadExcel($spreadsheet, $filename, $format) &#123; // $format只能为 Xlsx 或 Xls if ($format == 'Xlsx') &#123; header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); &#125; elseif ($format == 'Xls') &#123; header('Content-Type: application/vnd.ms-excel'); &#125; header(\"Content-Disposition: attachment;filename=\" . urlencode($filename) . '.' . strtolower($format)); //. date('Y-m-d') header('Cache-Control: max-age=0'); $objWriter = IOFactory::createWriter($spreadsheet, $format); $objWriter-&gt;save('php://output'); exit; &#125; private function getColumn($row = 1) &#123; $index = $this-&gt;cellIndex[$this-&gt;config['column']]; return 'A' . $row . ':' . $index . $row; &#125; private function autoFitColumnWidthToContent($sheet, $fromCol, $toCol) &#123; if (empty($toCol)) &#123; //not defined the last column, set it the max one $toCol = $sheet-&gt;getColumnDimension($sheet-&gt;getHighestColumn())-&gt;getColumnIndex(); &#125; for ($i = $fromCol; $i &lt;= $toCol; $i++) &#123; $sheet-&gt;getColumnDimension($i)-&gt;setAutoSize(true); &#125; $sheet-&gt;calculateColumnWidths(); &#125;&#125; 使用方法1234567891011121314151617&lt;?phpuse helper\\Export;...// 设置表头$export = new Export( [ '测试标题', '测试标题2', '时间', ], [ ['11111111111111', '测试数据2', '2020-04-30'], ['测试数据1-1', '测试数据2-2', '2020-04-30'], ]);echo $export-&gt;createTable();exit; 效果","categories":[],"tags":[{"name":"php扩展类","slug":"php扩展类","permalink":"http://www.daichongweb.com/tags/php扩展类/"}]},{"title":"nginx负载均衡的实现","slug":"nginx负载均衡的实现","date":"2020-03-25T07:50:50.000Z","updated":"2021-09-03T05:56:57.934Z","comments":true,"path":"nginx负载均衡的实现/","link":"","permalink":"http://www.daichongweb.com/nginx负载均衡的实现/","excerpt":"负载均衡是什么？&emsp;负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 &emsp;负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 为什么要做负载均衡 服务器总是崩溃怎么办？ 一台服务器扛不住大量的并发怎么办？ …… &nbsp;有了这些问题，我相信你一定会用得到这个技术。最让人高兴的一点是：只需要你懂点nginx的配置就能完美的驾驭负载均衡的配置，至于配置之后可能出现的问题，再慢慢去研究也不迟。","text":"负载均衡是什么？&emsp;负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 &emsp;负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 为什么要做负载均衡 服务器总是崩溃怎么办？ 一台服务器扛不住大量的并发怎么办？ …… &nbsp;有了这些问题，我相信你一定会用得到这个技术。最让人高兴的一点是：只需要你懂点nginx的配置就能完美的驾驭负载均衡的配置，至于配置之后可能出现的问题，再慢慢去研究也不迟。 架构图 &emsp;从上图可以看出，我们利用负载均衡可以很好的应对并发请求过高的情况，使每一台服务器发挥最大的效用。 负载均衡的实现方式 轮询(rr) ：按时间顺序逐一分配到不同的后端服务器(默认); 权重(weight)：加权轮询(wrr)。weight值越大，分配到的访问率越高; 源IP地址hash调度方法(ip_hash):将每个请求按访问IP的hash值来分配，来自同一个IP固定访问一个后端服务器; 最少连接数(least_conn)：当server拥有不同的权重时为wlc，当所有后端主机；连接数相同时，则使用wrr，适用于长连接(keepalive_timeout不为0); 实战配置&emsp;准备三台服务器：（1）192.168.133.128（调度器）（2）192.168.133.129（服务器1）（3）192.168.133.130（服务器2）&emsp;在调度服务器中配置：123456789101112131415161718192021upstream 192.168.133.128&#123; server 192.168.133.129:80 weight=1; server 192.168.133.130:80 weight=1;&#125;server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; client_max_body_size 50m; client_body_buffer_size 256k; location / &#123; proxy_pass http://192.168.133.128; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; &#125; &emsp;其他服务器server_name都配置成自己的IP就行。在各自的服务Html里命名，加以区分。 测试","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.daichongweb.com/tags/nginx/"}]},{"title":"用最少的Sql实现一个特殊排行榜","slug":"用最少的Sql实现一个特殊排行榜","date":"2020-01-21T00:24:28.000Z","updated":"2021-09-03T05:56:57.986Z","comments":true,"path":"用最少的Sql实现一个特殊排行榜/","link":"","permalink":"http://www.daichongweb.com/用最少的Sql实现一个特殊排行榜/","excerpt":"引言&emsp;说起排行榜上一篇已经介绍过了用Redis实现的方法，而这篇完全是用Sql来实现，不使用任何缓存。 需求功能（1）&emsp;现有十个同学，年龄分布如下图所示，假设你是戴七，请根据年龄获得你在这十人中排第几？同时请获得你的前一名和后一名各是哪一位同学？ &emsp;这个题是我去年在一家公司被问到的面试题。根据上图分析，获取到自己的排名并不是难事，那前一名和后一名也非常简单了。","text":"引言&emsp;说起排行榜上一篇已经介绍过了用Redis实现的方法，而这篇完全是用Sql来实现，不使用任何缓存。 需求功能（1）&emsp;现有十个同学，年龄分布如下图所示，假设你是戴七，请根据年龄获得你在这十人中排第几？同时请获得你的前一名和后一名各是哪一位同学？ &emsp;这个题是我去年在一家公司被问到的面试题。根据上图分析，获取到自己的排名并不是难事，那前一名和后一名也非常简单了。 自己的排名12// 原生写法select count(*) from `rank` where `age` &gt; 22 or (`age` = 22 and `created_at` &gt; '2020-01-21 09:05:34'); 123456// Laravel框架写法$my = DB::table('rank')-&gt;where('name', '戴七')-&gt;first();$rank = DB::table('rank')-&gt;where('age', '&gt;', $my-&gt;age)-&gt;orWhere(function ($query) use ($my) &#123; $query-&gt;where('age', '=', $my-&gt;age)-&gt;where('created_at', '&gt;', $my-&gt;created_at);&#125;)-&gt;count();$myRank = $rank + 1; &emsp;这里要注意的是：如果两个人的年龄相同，那么就要比较时间。最终得到的是年龄大于自己人有多少个，+1就是自己的排名。 前一名1234// 通过上面的Sql得知年龄大于自己的人数是6人$rankNum = 6;$top = $rankNum - 1;select * from rank where age &gt; 22 order by age desc limit $top,1 后一名1select * from `rank` where `age` &lt; 22 or (`age` = 22 and `created_at` &lt; '2020-01-21 09:05:34') order by age desc,created_at desc limit 1 &emsp;这里和原始Sql不同的是：年龄是&lt;22，时间也是&lt;自己的出生时间。 需求功能（2）&emsp;还是这十名同学，假设戴七同学就是本人，现需要五名同学的年龄作为参考，要求这分别得知你本人的前两名同学和后两名同学都是谁（五名同学中必须包含你自己）？ 特殊情况：&emsp;（1）如果你是第一名，那么就获得你后面的四位同学。&emsp;（2）如果你是第二名，那么就获得你前面的一名+后面的三名同学。&emsp;（3）如果你是倒数第一名，那么就获得你前面的四位同学。&emsp;（4）如果你是倒数第二名，那么就获得你前面的三名+后面的一位同学。&emsp;（5）可使用其他语言辅助解决问题，但尽可能的简单清晰。 答案12345678910111213$myRank = $rank + 1;$total = Db::table('rank')-&gt;count();// 如果排名是在前三名if ($myRank &lt;= 3) &#123; select * from rank where 1 order by age desc,created_at desc limit 5;&#125; else if (($total - $myRank) &lt;= 2) &#123; // 倒数两名 $unRank = $total - $myRank + 1; $offset = $myRank - 6 + $unRank; select * from rank where 1 order by age desc,created_at desc limit $offset,5;&#125; else &#123; $offset = $myRank - 3; select * from rank where 1 order by age desc,created_at desc limit $offset,5;&#125;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.daichongweb.com/tags/mysql/"}]},{"title":"php+redis实现实时排行榜","slug":"php-redis实现实时排行榜","date":"2019-12-19T05:14:25.000Z","updated":"2021-09-03T05:56:57.941Z","comments":true,"path":"php-redis实现实时排行榜/","link":"","permalink":"http://www.daichongweb.com/php-redis实现实时排行榜/","excerpt":"介绍&emsp;说起排行榜大家肯定不陌生，在项目开发中排行榜的运用非常的多。如王者农药的天梯排行榜、商城的销量排行榜、热卖榜、用户积分排行榜等等。不管他是什么类型的排行榜，其业务逻辑、实现方法几乎是完全相同的。&emsp;如这样的一个手机和笔记本的销量排行榜是如何实现的呢？","text":"介绍&emsp;说起排行榜大家肯定不陌生，在项目开发中排行榜的运用非常的多。如王者农药的天梯排行榜、商城的销量排行榜、热卖榜、用户积分排行榜等等。不管他是什么类型的排行榜，其业务逻辑、实现方法几乎是完全相同的。&emsp;如这样的一个手机和笔记本的销量排行榜是如何实现的呢？ 例子 榜单实现&emsp;假设做一个如上图一样的排行榜，规定榜单必须是实时更新的，你会使用什么技术来实现呢？ 方案一&emsp;在数据库新建一张数据表，通过下单事件钩子来更新这张表的数据，记录销量情况。1select id,name,image from goods left join goods_top on goods.id=goods_top.goods_id where sales &gt; 0 order by sales desc limit 10; &emsp;最常见、最简单的写法莫过于此，但这个写法有一个非常严重的问题。假设goods中数据规模极大，记录表goods_top表中数据规模也不小，在每次查询的性能消耗无疑是很大的，在极端的情况下甚至可能会出现请求超时的情况。 &emsp;这个方案在实际的项目运用中也很少出现，除非你能确定数据表规模一定会非常的小，或者你根本不考虑什么性能的情况下才会使用。 方案二&emsp;使用redis的有序集合(zset)来实现实时排行榜。关于redis有序集合的相关介绍、原理什么的大家自行百度 &emsp;(1)Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。&emsp;(2)不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。&emsp;(3)有序集合的成员是唯一的,但分数(score)却可以重复。&emsp;(4)集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 &emsp;也就是说，我们可以通过下单事件钩子创建一个zset集合，我们通过value来区分是哪个商品，通过score来排名。 具体代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpuse Illuminate\\Support\\Facades\\Redis;/** * 商品销量排行榜 */class Rank&#123; // key private static function key() &#123; $activeActivityId = Main::info(); return \"goods_top\"; &#125; // 增加销量 public static function add($id, $number) &#123; return Redis::zIncrBy(self::key(), $number, $id); &#125; // 获取销量 static function get($id) &#123; return Redis::zScore(self::key(), $id); &#125; // 获取成员排名-正序 static function getRank($id) &#123; return Redis::zrevrank(self::key(), $id); &#125; // 通过排名获取成员 static function getRevRange($start, $stop): array &#123; return Redis::zRevRange(self::key(), $start, $stop); &#125;&#125; 如何使用1234Rank::add(1008,10); // 商品ID为1008的销量增加10Rank::get(1008); // 获取商品ID为1008的销量Rank::getRank(1008); // 获取商品ID为1008的排名Rank::getRevRange(0,9); // 获取排名前十的商品ID,返回数组 总结&emsp;实现排行榜的方式有很多，大家根据具体需求和现有技术来确定实现方案。不要过分的追求性能或者是开发速度，欲速则不达。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"php7.4预加载与swoole常驻内存有何区别？","slug":"php7-4预加载与swoole常驻内存有何区别？","date":"2019-12-14T01:52:57.000Z","updated":"2021-09-03T05:56:57.942Z","comments":true,"path":"php7-4预加载与swoole常驻内存有何区别？/","link":"","permalink":"http://www.daichongweb.com/php7-4预加载与swoole常驻内存有何区别？/","excerpt":"重大新闻 php7.4在2019/11/28日发布！","text":"重大新闻 php7.4在2019/11/28日发布！其中RFC: Preloading（预加载）最引人瞩目。这一新特性的诞生标志着php作为解释型语言在性能瓶颈上再次突破。 根据各大网友的测试统计，php7.4与php7.0相比提升将近10%。 特性介绍php生命周期 每次请求php都会从0到1重复上图所示的操作，每次带来的内存、IO方面的消耗无疑是很大的。 预加载 在预加载的特性下，php会当预加载完成后的请求直接会命中缓存，省下了编译、语法解析、语法分析、类库引入等等操作。 这里你会发现怎么和swoole的常驻内存有点像？ 不过说实话，在没有真正使用的情况下还真没法判断两者的区别。 关于更详细的预加载使用大家可以看这里：php7.4 preload(预加载) 欢迎大家来讨论有关于预加载和常驻内存的区别到底是什么？","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"php+element+aliyunOss实现单图web直传","slug":"php-element-aliyunOss实现单图web直传","date":"2019-12-07T09:45:43.000Z","updated":"2021-09-03T05:56:57.937Z","comments":true,"path":"php-element-aliyunOss实现单图web直传/","link":"","permalink":"http://www.daichongweb.com/php-element-aliyunOss实现单图web直传/","excerpt":"业务逻辑原有业务","text":"业务逻辑原有业务 和数据直传到 OSS 相比，以上方法有三个缺点： 上传慢：用户数据需先上传到应用服务器，之后再上传到OSS。网络传输时间比直传到OSS多一倍。如果用户数据不通过应用服务器中转，而是直传到OSS，速度将大大提升。而且OSS采用BGP带宽，能保证各地各运营商之间的传输速度。 扩展性差：如果后续用户多了，应用服务器会成为瓶颈。 费用高：需要准备多台应用服务器。由于OSS上传流量是免费的，如果数据直传到OSS，不通过应用服务器，那么将能省下几台应用服务器。 代替业务 使用Oss web直传，能有效的解决上传速度过慢的问题。 实践php后端签名代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 阿里Oss上传验签类 */class OssPolicy&#123; private function gmtIso8601($time) &#123; $dtStr = date(\"c\", $time); $mydatetime = new DateTime($dtStr); $expiration = $mydatetime-&gt;format(DateTime::ISO8601); $pos = strpos($expiration, '+'); $expiration = substr($expiration, 0, $pos); return $expiration . \"Z\"; &#125; /** * 获取签名 */ public function policy() &#123; $id = Config('aliyun.webOss.accessKeyId'); // oss accessKeyId $key = Config('aliyun.webOss.accessKeySecret'); // oss accessKeySecret $host = Config('aliyun.webOss.host'); // oss 上传地址 $callbackUrl = Config('aliyun.webOss.callbackUrl');// 回调地址 这个可以忽略 $dir = Config('aliyun.webOss.dir'); // 存放的文件夹 $callback_param = array( 'callbackUrl' =&gt; $callbackUrl, 'callbackBody' =&gt; 'filename=$&#123;object&#125;&amp;size=$&#123;size&#125;&amp;mimeType=$&#123;mimeType&#125;&amp;height=$&#123;imageInfo.height&#125;&amp;width=$&#123;imageInfo.width&#125;', 'callbackBodyType' =&gt; \"application/x-www-form-urlencoded\" ); $callback_string = json_encode($callback_param); $base64_callback_body = base64_encode($callback_string); $now = time(); $expire = 30; $end = $now + $expire; $expiration = $this-&gt;gmtIso8601($end); $condition = array(0 =&gt; 'content-length-range', 1 =&gt; 0, 2 =&gt; 1048576000); $conditions[] = $condition; $start = array(0 =&gt; 'starts-with', 1 =&gt; '$key', 2 =&gt; $dir); $conditions[] = $start; $arr = array('expiration' =&gt; $expiration, 'conditions' =&gt; $conditions); $policy = json_encode($arr); $base64_policy = base64_encode($policy); $string_to_sign = $base64_policy; $signature = base64_encode(hash_hmac('sha1', $string_to_sign, $key, true)); $response = array(); $response['accessid'] = $id; $response['host'] = $host; $response['policy'] = $base64_policy; $response['signature'] = $signature; $response['expire'] = $end; $response['callback'] = $base64_callback_body; $response['dir'] = $dir; return $response; &#125;&#125; 封装组件 ossSingleUpload.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;div&gt; &lt;el-upload list-type=\"picture-card\" class=\"avatar-uploader\" action=\"http://daichongwbe.oss-cn-beijing.aliyuncs.com\" // 上传地址 :data=\"dataObj\" accept=\".jpeg, .png, .jpg\" // 允许上传的文件 :multiple=\"false\" // 禁止多图上传 :before-upload=\"beforeUpload\" // 上传前回调 :on-success=\"handleUploadSuccess\" // 上传成功后回调 :limit=\"limit\" // 限制上传数量 :show-file-list=\"false\" // 禁止列表展示 ref=\"upload\" &gt; &lt;img v-if=\"imageUrl\" :src=\"imageUrl\" class=\"avatar\" /&gt; &lt;i v-else class=\"el-icon-plus avatar-uploader-icon\"&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; getPolicy &#125; from \"@/api/oss/token\"; // 后端验签接口export default &#123; name: \"ossSingleUpload\", //组件命名 props: &#123; limit: Number, // 参数 imgCover: String // 参数 &#125;, data() &#123; return &#123; dataObj: &#123; policy: \"\", signature: \"\", key: \"\", ossaccessKeyId: \"\", dir: \"\", host: \"\", callback: \"\" &#125;, imageUrl: \"\" &#125;; &#125;, created() &#123; setTimeout(() =&gt; &#123; this.imageUrl = this.imgCover; &#125;, 500); &#125;, methods: &#123; emitInput(val) &#123; // 组件交互 this.$emit(\"input\", val); &#125;, beforeUpload(file) &#123; // 上传前钩子 let _self = this; return new Promise((resolve, reject) =&gt; &#123; getPolicy() .then(response =&gt; &#123; _self.dataObj.policy = response.data.policy; _self.dataObj.signature = response.data.signature; _self.dataObj.ossaccessKeyId = response.data.accessid; _self.dataObj.key = response.data.dir + \"$&#123;filename&#125;\"; _self.dataObj.dir = response.data.dir; _self.dataObj.host = response.data.host; _self.dataObj.callback = response.data.callback; resolve(true); &#125;) .catch(err =&gt; &#123; console.log(err); reject(false); &#125;); &#125;); &#125;, handleUploadSuccess(res, file) &#123; // 上传成功后 // 清除上次的上传记录，这里如果不清除会导致第二次上传无效。 this.$refs.upload.clearFiles(); // 组装图片路径，这里根据业务需要来。 this.imageUrl = this.dataObj.host + \"/\" + this.dataObj.dir + file.name; // 组件交互，把图片路径发送给页面 this.$emit(\"getMessage\", this.imageUrl); &#125; &#125;&#125;;&lt;/script&gt; 1234567891011121314151617181920.avatar-uploader .el-upload &#123; border: 1px dashed #d9d9d9; border-radius: 6px; cursor: pointer; position: relative; overflow: hidden;&#125;.avatar-uploader .el-upload:hover &#123; border-color: #409eff;&#125;.avatar-uploader-icon &#123; width: 100%; font-size: 28px; color: #8c939d; text-align: center;&#125;.avatar &#123; width: 100%; display: block;&#125; 页面调用12345678910111213141516171819202122&lt;template&gt; &lt;div class=\"app-container\"&gt; &lt;oss-single-upload @getMessage=\"coverImg\" :imgCover=\"imgCover\" :limit=\"1\"&gt;&lt;/oss-single-upload&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ossSingleUpload from \"@/components/Upload/ossSingleUpload\"; // 引入组件export default &#123; components: &#123; ossSingleUpload &#125;, data() &#123; return &#123; imgCover:\"\" &#125;; &#125;, methods: &#123; coverImg(imgUrl) &#123; console.log(imgUrl); //得到的上传图片路径 &#125; &#125;&#125;;&lt;/script&gt; 请求结果 在callbackurl为空或者callbackurl文件内容错误的情况下，这里是没有返回值的。 效果展示 github仓库点击查看源代码","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.daichongweb.com/tags/vue/"}]},{"title":"Laravel消息队列","slug":"Laravel消息队列","date":"2019-12-05T02:56:23.000Z","updated":"2021-09-03T05:56:57.874Z","comments":true,"path":"Laravel消息队列/","link":"","permalink":"http://www.daichongweb.com/Laravel消息队列/","excerpt":"思维导图","text":"思维导图 消息队列（MQ）什么是消息队列(MQ)关于消息队列大家肯定都不陌生，基本上每个项目中都会使用到的技术，在我前几期的博文中也有介绍。 &emsp;消息队列本质就是逻辑执行顺序，队列就如同一摞碗堆放在一起，你每放一个碗都会放在这螺碗的最上面，当你拿碗的时候也是只能从最上面拿。这个如同队列的消费特性（队列的特性是先进先出，先进后出，道理是一样的）。 为什么要使用消息队列？ 提高系统性能（削峰，减少响应时间）。1234567# 假设你有一个这样的接口# 新用户注册发送邮件验证码public function SendMailCode(Request $request)&#123; $mail = $request-&gt;input(&apos;mail); SendReminderEmail::dispatch($mail); // 把邮箱加入队列 return &apos;验证码发送成功，请注意查收！&apos;;&#125; &emsp;假设注册接口的并发在1秒100，在使用队列的情况下发送邮件这个操作是异步的，也就是说当第100名用户点击获取验证码后立刻就能获得响应，无需等待前99名所有邮件发送成功后才能得到相应，这就是不阻塞。当SendReminderEmail::dispatch($mail)执行之后立刻就会执行 return &#39;验证码发送成功，请注意查收！&#39;，控制器不需要知道邮件是否发送成功，减少了阻塞的等待时间。 降低系统的耦合性。传统写法 消息队列（MQ）写法 消息队列（MQ）的优缺点 优点：上边已经讲过了。 缺点：&emsp; (1)系统可用性降低:可以看出引入了MQ之后，如果MQ挂了相当于整个日志系统也随之崩溃。&emsp; (2)系统复杂性提高:引入MQ增加了维护系统的工作量，出现问题的可能性会更高。&emsp; (3)一致性问题。 队列的应用&emsp;Laravel中的消息队列就非常简单了，他可以设置驱动和执行方式。 安装扩展 aws/aws-sdk-php ~3.0 pda/pheanstalk ~3.0 predis/predis ~1.0 生成任务类1php artisan make:job SendReminderEmail 任务类结构123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace App\\Jobs;use Illuminate\\Bus\\Queueable;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\Dispatchable;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Queue\\SerializesModels;class SendReminderEmail implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $id; // 接收外部传入的参数 /** * Create a new job instance. * * @return void */ public function __construct($id) &#123; $this-&gt;id = $id; // 接收外部传入的参数 &#125; /** * Execute the job. * * @return void */ public function handle() &#123; echo 'jobsss' . $this-&gt;id; &#125;&#125; 加入队列123use SendReminderEmail;SendReminderEmail::dispatch($id); // 加入队列ehco 1; 测试结果&emsp;（1）当我未开启消息队列服务的情况下，直接请求接口，会返回1。&emsp;（2）开启消息队列 消息队列的选择&emsp;一般情况下大部分业务都使用的是redis的消息队列。加入你们公司业务量非常大，几千万甚至几亿就必须考虑使用其他的MQ工具。如ActiveMQ、RabbitMQ、RocketMQ、Kafka。 总结&emsp;Laravel的消息队列应用比较简单且非常的好用，建议大家可以尝试一下。具体可以看官方文档。","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://www.daichongweb.com/tags/laravel/"}]},{"title":"架构之路-mysql主从复制配置篇","slug":"架构之路-mysql主从复制配置篇","date":"2019-11-12T05:09:52.000Z","updated":"2021-09-03T05:56:57.981Z","comments":true,"path":"架构之路-mysql主从复制配置篇/","link":"","permalink":"http://www.daichongweb.com/架构之路-mysql主从复制配置篇/","excerpt":"前篇回忆上一篇介绍了主从复制的搭建的基础流程，为这篇的配置做了铺垫。便于理解是这篇最大的亮点，说实话经过亲手尝试了主从复制之后，感觉这个东西确实不难，就简单的改几个配置就可以搞定，但是作为高级程序优化的一部分，学习还是很有必要的。","text":"前篇回忆上一篇介绍了主从复制的搭建的基础流程，为这篇的配置做了铺垫。便于理解是这篇最大的亮点，说实话经过亲手尝试了主从复制之后，感觉这个东西确实不难，就简单的改几个配置就可以搞定，但是作为高级程序优化的一部分，学习还是很有必要的。 配置介绍确认环境1.服务器1号：192.168.22.130（主库服务器）2.服务器2号：192.168.22.128（从库服务器） 主库配置1234567vi /etc/my.cnf# 配置主库标识（这里数字随意，但是一定要比从库配置的数字大，必须是数字）server_id=1# 开启日志功能&amp;配置日志文件log_bin=master_log# 保存退出&amp;重启mysql服务systemctl restart mysqld 配置从库连接用户12345678910# 登陆mysqlmysql -uroot -p# 进入mysql库use mysql# 新增一个用户，并且绑定这个用户只能从192.168.22.128这个IP访问grant all privileges on *.* to 'slave'@'192.168.22.128' identified by 'slave123' with grant option;# 刷新权限flush privileges;# 这里要注意，真实的正式环境配置需要规定从库的连接IP，不能设置为*。# 密码不能设置过于简单，最少是字母和数字组合的6位，否则会报错。 查看主库状态show master status这里的File就是主库的binlog文件。 从库配置1234567891011121314151617181920vi /etc/my.cnf# 这里只需要配置一个标识就行(一定要比主库的标识数字小)server_id=2# 重启mysql服务systemctl restart mysqld# 关闭slavestop slave# 给从库配置主库参数mysql&gt; change master to-&gt; master_host=\"ip地址\"，-&gt; master_user=\"授权时指定的用户名\"，-&gt; master_password=\"用户密码\"，-&gt; master_log_file=\"binlog日志\"，-&gt; master_log_pos=偏移量；# 重启从库服务start slave# 测试是否正常连接show slave status \\G;# 如果报错error connecting to master 'repluse@192.168.22.130:3306' - retry-time: 60 retries:1# 请检查密码是不是配置错了 最后测试同步再主库创建一个数据表，然后刷新从库看看是否同步成功。 总结总体流程下来很简单、流程也不复杂、出现奇怪问题的几率小。如果在配置中遇到问题，可在评论区提问，我会第一时间回复。预告：下一篇是读写分离的配置","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.daichongweb.com/tags/架构/"}]},{"title":"架构之路-mysql主从复制基础搭建篇","slug":"架构之路-mysql主从复制基础搭建篇","date":"2019-11-12T02:18:09.000Z","updated":"2021-09-03T05:56:57.978Z","comments":true,"path":"架构之路-mysql主从复制基础搭建篇/","link":"","permalink":"http://www.daichongweb.com/架构之路-mysql主从复制基础搭建篇/","excerpt":"引言本文介绍的是在虚拟机上搭建，实际情况其实和真正的线上环境一毛一样，使用的系统是Centos 7。 什么是主从复制？原理是什么？答：简单点理解，主从复制其实就是两个数据库数据的项目备份过程。其原理就是主库产生的操作都会生成binlog传入从库，从库通过I/O线程把binlog写入relaylog，然后从库创建I/O线程执行relaylog进行数据备份。","text":"引言本文介绍的是在虚拟机上搭建，实际情况其实和真正的线上环境一毛一样，使用的系统是Centos 7。 什么是主从复制？原理是什么？答：简单点理解，主从复制其实就是两个数据库数据的项目备份过程。其原理就是主库产生的操作都会生成binlog传入从库，从库通过I/O线程把binlog写入relaylog，然后从库创建I/O线程执行relaylog进行数据备份。 流程图 为什么要做主从复制？答：一方面是为了备份数据，防止数据丢失和破坏，另一方面是为读写分离做铺垫。 搭建步骤新建虚拟机首先在本地安装虚拟机，我个人比较推荐 VMware Workstation Pro，当然也可以是使用其他的。虚拟机的安装就不做介绍了，无非都是下一步下一步。安装好之后在需要下载对用的系统镜像，因为本文主要是在Centos上做演示，所以我就下载了Centos的镜像，但是无法分享给大家，因为太大了，足足4G。 安装好之后新建两个虚拟机(怎么新建虚拟机就不做介绍了): 安装mysql注意：尽量两个虚拟机上的mysql版本保持一直，避免出现不可预知的错误。我安装的版本是5.7.1234567891011121314# 进入cd /usr/local/src# 下载rpm包wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm# 安装rpmrpm -ivh mysql57-community-release-el7-11.noarch.rpm# 安装 mysql-serveryum install -y mysql-server# 启动 systemctl start mysqld# 设置开机自启systemctl enable mysqld# 登陆mysqlmysql -uroot -p 因为5.7之后的版本都是禁止匿名登陆的，你可以通过查看密码并登陆，然后修改密码，或者直接修改my.cnf来禁止登陆验证。1cat /var/log/mysqld.log|grep 'A temporary password' 因为系统给我的默认密码含有一些特殊符号，我没法输入，我只能使用第二种方法：12345678910vi \\etc\\my.cnf# 在最后增加一行skip-grant-tables=1# 登陆mysql，刷新权限flush privileges;# 修改密码use mysql;update user set password='password' where user='root'；# 修改成功后再次刷新权限# 最后重启一下mysql服务 本地连接虚拟机上的mysql123# 查看IPifconfig# 在本地Cmd中ping这个IP 使用telnet测试mysql连接状态1telnet 192.168.22.130 3360 错误的情况（因我这里是好的，所以我把3306填成了3360） 检查虚拟机是否安装了iptables123456789# 关闭防火墙systemctl stop firewalld# 禁止防火墙systemctl mask firewalld# 禁止开机启动systemctl disable firewalld# 如果实在不行，还要把selinux关闭vi /etc/selinux/configSELINUX=disabled 再次使用telnet 192.168.22.130 3306还是报错上边图片所示时。 配置权限12345# 创建一个用户GRANT ALL PRIVILEGES ON *.* TO 'daichong'@'%' IDENTIFIED BY 'daichong' WITH GRANT OPTION;# 刷新权限FLUSH PRIVILEGES;# 这里注意真实线上情况权限不能这么开 出现这个说明已经成功了 使用navicat连接 到这里基础的安装已经完成了，如果遇到问题可在评论中提问，下一篇介绍主从复制如何配置。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.daichongweb.com/tags/架构/"}]},{"title":"laravel模型关联查询与JOIN哪个性能好","slug":"laravel模型关联查询与JOIN哪个性能好","date":"2019-11-08T08:34:03.000Z","updated":"2021-09-03T05:56:57.930Z","comments":true,"path":"laravel模型关联查询与JOIN哪个性能好/","link":"","permalink":"http://www.daichongweb.com/laravel模型关联查询与JOIN哪个性能好/","excerpt":"初学Laravel 最近接手一个新项目，整个项目完全看不到left join这样的写法，我打印了模型关联查询后的sql后发现跟常有的查询写法完全不同。原谅我一直是个码农，几乎没见过这样的写法，一直想对比一下这样的写法和常用的写法性能方面到底有什么差别。","text":"初学Laravel 最近接手一个新项目，整个项目完全看不到left join这样的写法，我打印了模型关联查询后的sql后发现跟常有的查询写法完全不同。原谅我一直是个码农，几乎没见过这样的写法，一直想对比一下这样的写法和常用的写法性能方面到底有什么差别。一个小栗子 模型关联生成的sql1select * from `comment` where exists (select * from `post_comment` where `comment`.`id` = `post_comment`.`comment_id` and `post_id` = ?) 常用查询1SELECT `comment`.id,`comment`.info,`comment`.user_id from `comment` left join post_comment on `comment`.id = `post_comment`.comment_id where post_comment.post_id = ? 单从sql上看区别还是挺大的，再做码农的期间，最常听到的就是链表查询性能不好。但是还真不能确定这两个sql到底哪个性能好一点，没办法只能测试一下。 posts Tables id title time 1 模型关联查询 2019-11-08 2 left join 查询 2019-11-08 comment Tables id info time 1 模型关联查询的性能好 2019-11-08 2 left join 查询的性能好 2019-11-08 3 两个都挺好 2019-11-08 post_comment Tables id post_id comment_id 1 1 1 2 2 2 3 3 2 为了避免争议，我添加了一些比较合理的数据。 数据量 posts comment post_comment 29999条 29999条 29999条 下面使用EXPLAIN进行分析1EXPLAIN select * from `comment` where exists (select * from `post_comment` where `comment`.`id` = `post_comment`.`comment_id` and `post_id` = 2) select_type table partitions type PRIMARY comment NULL ALL DEPENDENT SUBQUERY post_comment NULL ref possible_keys key key_len ref NULL NULL NULL NULL post_id,comment_id post_id 5 const rows filtered Extra 29999 100.00 Using where 1 10.00 Using where 1EXPLAIN SELECT `comment`.id,`comment`.info,`comment`.user_id from `comment` left join post_comment on `comment`.id = `post_comment`.comment_id where post_comment.post_id = 2 select_type table partitions SIMPLE post_comment NULL SIMPLE comment NULL type possible_keys key key_len ref post_id,comment_id post_id 5 eq_ref PRIMARY PRIMARY 4 ref rows filtered Extra const 1 100.00 Using where test.post_comment.comment_id 1 100.00 NULL 从上边的EXPLAIN结果来看，left join比模型关联的写法效率高太多了，之后我在laravel社区也发布了相关的提问，得到的结论是数据量大的时候用JOIN，数据量小的时候用模型。 从得的的结论来看，模型并适合大数据查询，但是对一些新增、修改、删除操作提供了很好的效果！","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://www.daichongweb.com/tags/laravel/"}]},{"title":"laravel模型关联","slug":"laravel模型关联","date":"2019-11-06T09:30:11.000Z","updated":"2021-09-03T05:56:57.929Z","comments":true,"path":"laravel模型关联/","link":"","permalink":"http://www.daichongweb.com/laravel模型关联/","excerpt":"一对一 &emsp;什么是一对多？ &emsp;在程序角度讲：一对多基本上都是用来描述两个数据表之间的关系。 &emsp;假设现有两个数据表：（1）文章表posts （2）评论表comment。一个文章可以有多个评论，但一个评论只能属于一个文章，相对于评论来说它与文章的关系是多对一，相对与文章来说它与评论的关系是一对多，这也就是laravel里反向关联的基础。 文章表posts idtitletime1什么是一对一？2019-11-072什么是一对多？2019-11-083什么是多对多？2019-11-06","text":"一对一 &emsp;什么是一对多？ &emsp;在程序角度讲：一对多基本上都是用来描述两个数据表之间的关系。 &emsp;假设现有两个数据表：（1）文章表posts （2）评论表comment。一个文章可以有多个评论，但一个评论只能属于一个文章，相对于评论来说它与文章的关系是多对一，相对与文章来说它与评论的关系是一对多，这也就是laravel里反向关联的基础。 文章表posts idtitletime1什么是一对一？2019-11-072什么是一对多？2019-11-083什么是多对多？2019-11-06评论表commentidinfouser_id1我知道什么是一对一。100862我知道什么是一对多。100853我知道什么是多对多。100844这谁不知道啊！10084 中间表posts_comment（也可以叫做关系表） idpost_idcomment_id111222333434 &emsp;从表的结构可以看出来，ID=1、2的文章只有一条评论，ID=3的文章有两条评论。 &emsp;那么这是要有个业务，已知文章的ID=3，请使用laravel的模型关联找出该文章下的所有评论。 &emsp;首先确认两个表之间的关系，一个评论在中间表只有一条数据，中间表里的comment_id肯定是唯一的，不可能出现一个评论同时属于两个文章，所以它们之间的关系是一对一。但是，你会发现使用hasMany(多对多)关联方法获取的数据居然是一样的。 模型关联12345678910# 一对多写法public function comments()&#123; return $this-&gt;hasMany(&apos;App\\Models\\PostComment&apos;, &apos;comment_id&apos;, &apos;id&apos;);&#125;# 一对一写法public function comment()&#123; return $this-&gt;hasOne(&apos;App\\Models\\PostComment&apos;, &apos;comment_id&apos;, &apos;id&apos;);&#125; 查询写法使用（with）12345678public function list()&#123; $postId = 3; $data = \\App\\Models\\Comment::with(&apos;comments&apos;)-&gt;whereHas(&quot;comments&quot;, function ($query) use ($postId) &#123; return $query-&gt;where(&quot;post_id&quot;, $postId); &#125;)-&gt;get(); dump($data-&gt;toArray());&#125; 获取的数据结果（使用with）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# with(&apos;comments);array:2 [▼ 0 =&gt; array:4 [▼ &quot;id&quot; =&gt; 3 &quot;info&quot; =&gt; &quot;\\t我知道什么是多对多&quot; &quot;user_id&quot; =&gt; 10084 &quot;comments&quot; =&gt; array:1 [▼ 0 =&gt; array:3 [▼ &quot;id&quot; =&gt; 3 &quot;post_id&quot; =&gt; 3 &quot;comment_id&quot; =&gt; 3 ] ] ] 1 =&gt; array:4 [▼ &quot;id&quot; =&gt; 4 &quot;info&quot; =&gt; &quot;这谁不知道啊！&quot; &quot;user_id&quot; =&gt; 10084 &quot;comments&quot; =&gt; array:1 [▼ 0 =&gt; array:3 [▼ &quot;id&quot; =&gt; 4 &quot;post_id&quot; =&gt; 3 &quot;comment_id&quot; =&gt; 4 ] ] ]]# with(&apos;comment);array:2 [▼ 0 =&gt; array:4 [▼ &quot;id&quot; =&gt; 3 &quot;info&quot; =&gt; &quot;\\t我知道什么是多对多&quot; &quot;user_id&quot; =&gt; 10084 &quot;comment&quot; =&gt; array:3 [▼ &quot;id&quot; =&gt; 3 &quot;post_id&quot; =&gt; 3 &quot;comment_id&quot; =&gt; 3 ] ] 1 =&gt; array:4 [▼ &quot;id&quot; =&gt; 4 &quot;info&quot; =&gt; &quot;这谁不知道啊！&quot; &quot;user_id&quot; =&gt; 10084 &quot;comment&quot; =&gt; array:3 [▼ &quot;id&quot; =&gt; 4 &quot;post_id&quot; =&gt; 3 &quot;comment_id&quot; =&gt; 4 ] ]] 执行的SQL（使用with）12345678910111213# 两次sql是一样的array:2 [▼ 0 =&gt; array:3 [▼ &quot;query&quot; =&gt; &quot;select * from `comment` where exists (select * from `post_comment` where `comment`.`id` = `post_comment`.`comment_id` and `post_id` = ?)&quot; &quot;bindings&quot; =&gt; array:1 [▶] &quot;time&quot; =&gt; 12.67 ] 1 =&gt; array:3 [▼ &quot;query&quot; =&gt; &quot;select * from `post_comment` where `post_comment`.`comment_id` in (3, 4)&quot; &quot;bindings&quot; =&gt; [] &quot;time&quot; =&gt; 0.21 ]] &emsp;我们分析一下laravel底层的处理逻辑，从上边的sql可以看出使用模型关联第一步会使用一个嵌套查询找出comment在post_comment里存在的结果集，最终的得到的结果是3、4。随后会做一个IN查询得到最终comment.id=3、4的数据最后合并成结果集返回。 查询写法使用（不使用with）123456789public function list()&#123; $postId = 3; $data = \\App\\Models\\Comment::whereHas(&quot;comment&quot;, function ($query) use ($postId) &#123; return $query-&gt;where(&quot;post_id&quot;, $postId); &#125;)-&gt;get(); dump($data-&gt;toArray());&#125; 执行的SQL（不使用with）12345678# 两次执行sql也是一样的array:1 [▼ 0 =&gt; array:3 [▼ &quot;query&quot; =&gt; &quot;select * from `comment` where exists (select * from `post_comment` where `comment`.`id` = `post_comment`.`comment_id` and `post_id` = ?)&quot; &quot;bindings&quot; =&gt; array:1 [▶] &quot;time&quot; =&gt; 2.82 ]] 查询的结果（不使用with）12345678910111213# 得到的结果也是一样的array:2 [▼ 0 =&gt; array:3 [▼ &quot;id&quot; =&gt; 3 &quot;info&quot; =&gt; &quot;\\t我知道什么是多对多&quot; &quot;user_id&quot; =&gt; 10084 ] 1 =&gt; array:3 [▼ &quot;id&quot; =&gt; 4 &quot;info&quot; =&gt; &quot;这谁不知道啊！&quot; &quot;user_id&quot; =&gt; 10084 ]] &emsp;两种写法的端异想必大家都能看得出来，就不再介绍了。 那么问题来了，为什么要使用模型关联呢？ &emsp;假设某一个文章被评论了，在不使用模型关联的情况下需要这样写： 普通写法123456789$mode = new \\App\\Models\\Comment();$mode-&gt;info = &apos;测试&apos;;$mode-&gt;user_id = 11;$mode-&gt;save();\\App\\Models\\PostComment::create([ &apos;post_id&apos; =&gt; 3, &apos;comment_id&apos; =&gt; $mode-&gt;id]); 模型关联写法12345678$mode = new \\App\\Models\\Comment();$mode-&gt;info = &apos;测试&apos;;$mode-&gt;user_id = 11;$mode-&gt;save();$mode-&gt;comment()-&gt;create([ &apos;post_id&apos; =&gt; 3,]); &emsp;而且我的公司有规定不能使用left join写法，而且模型中不允许写有关业务的代码，这样大大限制了随心所欲开发，降低了项目的维护成本。并且在使用模型关联后，一切的代码变得简单了，可读性提高，倒是性能这块我没有真正的测试过，之后肯定会研究一下。","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://www.daichongweb.com/tags/laravel/"}]},{"title":"vue+element实战（入门篇 一）","slug":"vue-element实战（入门篇）","date":"2019-11-03T05:12:51.000Z","updated":"2021-09-03T05:56:57.966Z","comments":true,"path":"vue-element实战（入门篇）/","link":"","permalink":"http://www.daichongweb.com/vue-element实战（入门篇）/","excerpt":"我为什么会学vue？ &emsp;学Vue之前一直觉得它好难，首先源代码看不懂，对于我一个主要是做PHP后端来说，看见那些import还有哪些花里胡哨的语法，真的是太难看懂了。&emsp;后来在机缘巧合的进了一家后台是用vue+element搭建的公司，因为公司的前端就一个，关键还是个妹子，也不好意给她增加工作量，基本上管理后台的后端代码和前端代码都需要我来写。 &emsp;好在框架已经搭建好了，我只需要写一些数据交互和数据渲染。 &emsp;更深入的了解Vue的设计思想点击这里： Vue官网、Vue设计思想。","text":"我为什么会学vue？ &emsp;学Vue之前一直觉得它好难，首先源代码看不懂，对于我一个主要是做PHP后端来说，看见那些import还有哪些花里胡哨的语法，真的是太难看懂了。&emsp;后来在机缘巧合的进了一家后台是用vue+element搭建的公司，因为公司的前端就一个，关键还是个妹子，也不好意给她增加工作量，基本上管理后台的后端代码和前端代码都需要我来写。 &emsp;好在框架已经搭建好了，我只需要写一些数据交互和数据渲染。 &emsp;更深入的了解Vue的设计思想点击这里： Vue官网、Vue设计思想。 vue到底难不难？ &emsp;从我真正接触vue来说，想真正把vue摸透确实很难，但是只想学会怎么用vue搭建后台管理系统这倒不难。 &emsp;当然这需要你有点前端的基础（html\\css\\js），在没有前端的基础情况下，入门vue确实有点难。 有一定前端的基础的情况下，怎么快速的入门vue？ &emsp;首先你要知道vue+elementUi或者其他ui开发的核心是什么？ &emsp;简单的举个栗子： 小栗子1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;el-table :data=\"tableData\"&gt; &lt;el-table-column prop=\"date\" label=\"日期\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"name\" label=\"姓名\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"address\" label=\"地址\"&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; tableData: [&#123; date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄' &#125;, &#123; date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' &#125;, &#123; date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' &#125;] &#125; &#125; &#125; &lt;/script&gt; &emsp;从代码可以看出Table的数据来源是Js里tableData数组，它们是通过Vue的特性双向绑定来实现的:data=”tableData”，字段通过:prop=”字段名”。 &emsp;那么在真实数据交互的情况下就这么写： 小栗子12345678910111213141516171819202122232425&lt;script&gt; export default &#123; data() &#123; return &#123; tableData: [] &#125; &#125;, created() &#123; // 页面创建后执行 this.getList(); // 查询数据 &#125;, methods: &#123; // 方法集合 getList()&#123; axios(&#123; // 首选你要安装 axios method:'get', url:'请求地址' &#125;).then(function(resp)&#123; // 请求成功，把数据赋值给tableData this.tableData = resp.data &#125;).catch(resp =&gt; &#123; // 请求失败 &#125;); &#125; &#125; &#125; &lt;/script&gt; &emsp;就这么简单，vue+element+axios数据交互和渲染已经完成了！","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.daichongweb.com/tags/vue/"}]},{"title":"Navicat Premium 12.1安装与激活","slug":"Navicat-Premium-12-1安装与激活","date":"2019-09-28T09:45:15.000Z","updated":"2021-09-03T05:56:57.877Z","comments":true,"path":"Navicat-Premium-12-1安装与激活/","link":"","permalink":"http://www.daichongweb.com/Navicat-Premium-12-1安装与激活/","excerpt":"前言 &emsp;（1）即将国庆，在我回老家之前给大家分享一波福利！ &emsp;（2）后端开发离不开数据库的管理，为了更加方便的管理数据，经常会使用一些数据库管理工。如phpMyAdmin、SQLyog、Workbench、 Navicat等等。 &emsp;（3）但我个人觉得从UI、功能上来说最优的是Navicat。 &emsp;（4）具体的功能就不做介绍了，本篇就教大家怎么破解使用最新版的Navicat，而且是破解官方版的哦，绝对不是那种从乱七八糟的网站上下载来的。 &emsp;（5）安全可靠，好用，官方收费3个月1699人民币，马上能免费用到他，想想就觉得兴奋。","text":"前言 &emsp;（1）即将国庆，在我回老家之前给大家分享一波福利！ &emsp;（2）后端开发离不开数据库的管理，为了更加方便的管理数据，经常会使用一些数据库管理工。如phpMyAdmin、SQLyog、Workbench、 Navicat等等。 &emsp;（3）但我个人觉得从UI、功能上来说最优的是Navicat。 &emsp;（4）具体的功能就不做介绍了，本篇就教大家怎么破解使用最新版的Navicat，而且是破解官方版的哦，绝对不是那种从乱七八糟的网站上下载来的。 &emsp;（5）安全可靠，好用，官方收费3个月1699人民币，马上能免费用到他，想想就觉得兴奋。 下载&amp;安装 &emsp;（1）官方最新版下载地址:Navicat Premium 12.1。 &emsp;（2）注册机下载地址： Navicat注册机。 破解 &emsp;（2）Navicat Premium 12.1安装步骤就不介绍了，直接都next就好了。 &emsp;（3）安装注册机（把杀毒软件全部退出）。 &emsp;（4）选择你对应的版本信息和语言。 &emsp;（5）点击Patch选择Navicat安装目录下的navicat.exe。 &emsp;（6）点击Generate生成注册码。 &emsp;（7）把注册码复制到软件中，点击激活，这里会提示激活失败，然后咱们点击手动激活。 &emsp;（8）把请求码复制到注册机中，如下面的位置，然后点击Generate，把返回的激活码再复制回软件中，点击激活。 &emsp;（9）激活成功。 最后 &emsp;然后就尽情的使用吧！！！！哈哈哈。","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://www.daichongweb.com/tags/开发工具/"}]},{"title":"swoole+websocket实现聊天室功能","slug":"swoole+websocket实现聊天室功能","date":"2019-09-25T02:43:15.000Z","updated":"2021-09-03T05:56:57.965Z","comments":true,"path":"swoole+websocket实现聊天室功能/","link":"","permalink":"http://www.daichongweb.com/swoole+websocket实现聊天室功能/","excerpt":"基础介绍 &emsp;（1）Swoole是一个面向生产环境的 PHP 异步网络通信引擎，使 PHP 开发人员可以编写高性能的异步并发 TCP、UDP、Unix Socket、HTTP，WebSocket 服务。Swoole 可以广泛应用于互联网、移动通信、企业软件、云计算、网络游戏、物联网（IOT）、车联网、智能家居等领域。 使用 PHP + Swoole 作为网络通信框架，可以使企业 IT 研发团队的效率大大提升。—百度百科 &emsp;（2）WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 —百度百科","text":"基础介绍 &emsp;（1）Swoole是一个面向生产环境的 PHP 异步网络通信引擎，使 PHP 开发人员可以编写高性能的异步并发 TCP、UDP、Unix Socket、HTTP，WebSocket 服务。Swoole 可以广泛应用于互联网、移动通信、企业软件、云计算、网络游戏、物联网（IOT）、车联网、智能家居等领域。 使用 PHP + Swoole 作为网络通信框架，可以使企业 IT 研发团队的效率大大提升。—百度百科 &emsp;（2）WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 —百度百科 &emsp;（3）那这篇的主题就是如何使用Swoole+WebSocket实现一个简易的聊天室。 &emsp;&emsp;熟悉网络通信协议的同学肯定不会陌生。 功能需求及问题处理 &emsp;web端：&emsp;&emsp;（1）每次刷新都会生成一个唯一的ID(id值从1开始).&emsp;&emsp;（2）第一次进入网站时会要求用户设置昵称并会与ID进行绑定。&emsp;问题点：&emsp;&emsp;（1）刷新页面后用户标识（ID）会重新生成，之前生成ID被弃用。&emsp;&emsp;（2）websocket生成了新的用户ID,但是跟现在的无法形成关联关系。 &emsp;server端：&emsp;（1）当用户进入聊天室后，发送广播给所有人并加入聊天群组（使用redis存储）。&emsp;（2）当用户退出直播间后，发送广播给所有人并清除该用户的记录。&emsp;（3）用户每发送一次消息都要形成新的记录广播给所有人。&emsp;（4）用户生成新的昵称后把昵称推送给他。 &emsp;web端问题处理方法：&emsp;（1）浏览器刷新时提醒用户刷新即将重新获得新的身份。&emsp;（2）用户连接成功后记录用户name,每次连接把这个name带上，清除之前该name的绑定关系，形成新的关系。 演示地址 &emsp;聊天室演示 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?phpinclude &quot;RedisManager.php&quot;;$server = new Swoole\\WebSocket\\Server(&quot;0.0.0.0&quot;, 8877);// 客户端连接$server-&gt;on(&apos;open&apos;, function (Swoole\\WebSocket\\Server $server, $request) &#123; //连接成功把当前在线的用户返回 $user_list = RedisConnect::getRedis()-&gt;hGetAll(&apos;message:user&apos;); alone($server, $request-&gt;fd, [ &apos;type&apos; =&gt; &apos;first&apos;, &apos;data&apos; =&gt; $user_list ]);&#125;);// 接收客户端发送的消息$server-&gt;on(&apos;message&apos;, function (Swoole\\WebSocket\\Server $server, $frame) &#123; $message_data = json_decode($frame-&gt;data, true); $type = $message_data[&apos;type&apos;]; $data = $message_data[&apos;user_name&apos;]; if (isset($message_data[&apos;send_message&apos;])) &#123; $user_message = $message_data[&apos;send_message&apos;]; &#125; switch ($type) &#123; case &apos;save_user&apos;: $new_name = &apos;大厦单子&apos; . $frame-&gt;fd . &apos;号&apos;; // 修改用户昵称 RedisConnect::getRedis()-&gt;hset(&apos;message:user&apos;, $frame-&gt;fd, $new_name); // 把生成的用户昵称返回给他 alone($server, $frame-&gt;fd, [ &apos;type&apos; =&gt; &apos;new_name&apos;, &apos;name&apos; =&gt; $new_name, &apos;id&apos; =&gt; $frame-&gt;fd ]); // 广播消息给其他用户 groupSending($server, [ &apos;type&apos; =&gt; &apos;open&apos;, &apos;name&apos; =&gt; $new_name, &apos;id&apos; =&gt; $frame-&gt;fd ]); break; case &apos;send_message&apos;: $msg = [ &apos;id&apos; =&gt; $frame-&gt;fd, &apos;user_name&apos; =&gt; $data, &apos;message&apos; =&gt; $user_message, &apos;type&apos; =&gt; &apos;message&apos; ]; // 接受用户发送的消息 RedisConnect::getRedis()-&gt;lpush(&apos;message:user:say&apos;, $msg); groupSending($server, $msg); break; &#125;&#125;);// 退出聊天室$server-&gt;on(&apos;close&apos;, function ($ser, $fd) &#123; $user = RedisConnect::getRedis()-&gt;hget(&apos;message:user&apos;, $fd); RedisConnect::getRedis()-&gt;hdel(&apos;message:user&apos;, $fd); $msg = [ &apos;id&apos; =&gt; $fd, &apos;user_name&apos; =&gt; $user, &apos;message&apos; =&gt; &apos;退出聊天室&apos;, &apos;type&apos; =&gt; &apos;close&apos; ]; groupSending($ser, $msg, $fd);&#125;);// 开启服务$server-&gt;start();// 群发消息function groupSending($server, $msg, $self = null)&#123; foreach ($server-&gt;connections as $conn) &#123; if ($conn == $self) break; //不再推送给当前退出的用户 $server-&gt;push($conn, json_encode($msg)); &#125;&#125;// 单独发消息function alone($server, $fd, $msg)&#123; $server-&gt;push($fd, json_encode($msg));&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;聊天室&lt;/title&gt; &lt;style&gt; *&#123;margin:0;padding:0&#125;.box&#123;width:602px;height:500px;margin:20px auto&#125;.body&#123;width:500px;height:500px;border:1px solid #333;padding:20px;box-sizing:border-box;float:right&#125;.title&#123;text-align:center;margin-top:10px&#125;.msg&#123;margin-top:20px;width:100%;text-align:left&#125;.message_box&#123;width:100%;height:90%;margin-top:10px;font-size:12px;overflow:hidden;overflow-y:auto&#125;.name&#123;font-weight:bold&#125;.right&#123;text-align:right&#125;.prompt&#123;width:600px;margin:0 auto&#125;.live&#123;width:100px;height:500px;float:left;border:1px solid #333;font-size:12px;text-align:center&#125;.live-box&#123;height:100%;overflow:hidden;overflow-y:auto&#125;.live-box p&#123;margin-top:10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;body&quot;&gt; &lt;div class=&quot;title&quot;&gt;+++++++++++聊天室++++++++++++&lt;/div&gt; &lt;div class=&quot;message_box&quot; id=&quot;test&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;live&quot;&gt; &lt;div class=&quot;live-title&quot;&gt;在线人数&lt;/div&gt; &lt;div class=&quot;live-box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;prompt&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;say&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;发送&quot; id=&quot;send&quot;&gt; &lt;!-- &lt;input type=&quot;button&quot; value=&quot;增加消息&quot; id=&quot;add&quot;&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onbeforeunload = function (event) &#123; window.localStorage.clear(); &#125;; $(function () &#123; window.user_name = &apos;&apos;; // 获取在线用户 if (!(&quot;WebSocket&quot; in window)) &#123; alert(&quot;您的浏览器不支持 WebSocket!&quot;); return false; &#125; // 连接 let ws = new WebSocket(&quot;ws://49.235.172.110:8877&quot;); //连接成功 ws.onopen = function (event) &#123; // 修改昵称 let user_info = &#123; &apos;type&apos;: &apos;save_user&apos;, &apos;user_name&apos;: &apos;&apos;, &#125;; ws.send(JSON.stringify(user_info)); console.log(&apos;连接成功&apos;, &apos;修改昵称成功&apos;); &#125;; ws.onmessage = function (evt) &#123; let received_msg = JSON.parse(evt.data); let type = received_msg[&apos;type&apos;]; switch (type) &#123; case &apos;message&apos;: add_msg(received_msg); break; case &apos;close&apos;: $(&quot;.live-box&quot;).find(&apos;p[user=&apos; + received_msg[&apos;id&apos;] + &apos;]&apos;).remove(); break; case &apos;connect&apos;: console.log(received_msg); break; case &apos;new_name&apos;: user_name = received_msg[&apos;name&apos;]; break; case &apos;open&apos;: $(&apos;.live-box&apos;).append(&apos;&lt;p user=&quot;&apos; + received_msg[&apos;id&apos;] + &apos;&quot;&gt;&apos; + received_msg[&apos;name&apos;] + &apos;&lt;/p&gt;&apos;); break; case &apos;first&apos;: let data = received_msg[&apos;data&apos;]; let str = &apos;&apos;; $.each(data, function (k, v) &#123; if (isNaN(v)) &#123; str += &apos;&lt;p user=&quot;&apos; + k + &apos;&quot;&gt;&apos; + v + &apos;&lt;/p&gt;&apos;; &#125; &#125;) $(&apos;.live-box&apos;).append(str); break; &#125; &#125; // 发送消息 $(&quot;#send&quot;).click(function () &#123; send_msg(); &#125;) $(&quot;input[name=say]&quot;).bind(&quot;keydown&quot;, function (e) &#123; var theEvent = e || window.event; var code = theEvent.keyCode || theEvent.which || theEvent.charCode; if (code == 13) &#123; send_msg(); &#125; &#125;); // 发送消息 function send_msg() &#123; var message = $(&apos;input[name=say]&apos;).val(); if (message !== &apos; &apos;) &#123; var arr = &#123; &apos;type&apos;: &apos;send_message&apos;, &apos;user_name&apos;: user_name, &apos;send_message&apos;: message &#125;; ws.send(JSON.stringify(arr)); &#125; $(&apos;input[name=say]&apos;).val(&apos; &apos;); var ele = document.getElementById(&quot;test&quot;); if (ele.scrollHeight &gt; ele.clientHeight) &#123; ele.scrollTop = ele.scrollHeight + 100; &#125; &#125; // 增加消息 function add_msg(data) &#123; let str = &apos;&lt;div class=&quot;msg&quot;&gt;&apos;; str += &apos;&lt;span class=&quot;name&quot;&gt;&apos; + data[&apos;user_name&apos;] + &apos;&lt;/span&gt;:&apos;; str += &apos;&lt;span class=&quot;text&quot;&gt;&apos; + data[&apos;message&apos;] + &apos;&lt;/span&gt;&lt;/div&gt;&apos;; $(&apos;.message_box&apos;).append(str); &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 总结 &emsp;这篇文章只是简单的介绍前后端如何实现通信，很多的细节问题没有进行处理。&emsp;UI比较low，这里大家只看代码就好了…&emsp;更多关于Swoole的功能还待探索…敬请期待…","categories":[],"tags":[{"name":"php扩展类","slug":"php扩展类","permalink":"http://www.daichongweb.com/tags/php扩展类/"}]},{"title":"WEB性能测试-并发测试","slug":"WEB性能测试-并发测试","date":"2019-09-18T07:07:45.000Z","updated":"2021-09-03T05:56:57.894Z","comments":true,"path":"WEB性能测试-并发测试/","link":"","permalink":"http://www.daichongweb.com/WEB性能测试-并发测试/","excerpt":"前篇回忆： &emsp;前两篇介绍了redis队列如何处理订单和JMeter的环境配置及安装方法，这篇根据程序开发的逻辑和习惯来解决几个问题： &emsp;&emsp;（1）JMeter并发测试的基本使用。&emsp;&emsp;（2）redis和mysql相比的性能差距如何？&emsp;&emsp;（3）大量的并发和请求下redis、mysql、nginx各自会出现的问题？&emsp;&emsp;（4）遇到并发带来各种各样的问题如何解决？","text":"前篇回忆： &emsp;前两篇介绍了redis队列如何处理订单和JMeter的环境配置及安装方法，这篇根据程序开发的逻辑和习惯来解决几个问题： &emsp;&emsp;（1）JMeter并发测试的基本使用。&emsp;&emsp;（2）redis和mysql相比的性能差距如何？&emsp;&emsp;（3）大量的并发和请求下redis、mysql、nginx各自会出现的问题？&emsp;&emsp;（4）遇到并发带来各种各样的问题如何解决？ 问题一：JMeter并发测试的基本使用 &emsp;（1）设置系统语言：Options-&gt;Choose Lanuage 里选择适合你的语言。&emsp;（2）添加线程组：&emsp;（3）设置线程属性：&emsp;&emsp;线程数：也就是并发数。&emsp;&emsp;Ramp-Up时间（秒）：并发时间，0为同时并发。&emsp;&emsp;循环次数：重复次数。&emsp;（4）添加HTTP请求：&emsp;&emsp;协议：http或https。&emsp;&emsp;服务器名称或IP：请求地址。&emsp;&emsp;路径：要请求的路由或文件路径。&emsp;&emsp;参数：添加请求参数。&emsp;（5）添加察看结果树：可查看发送的数据，返回的结果等。&emsp;（6）添加汇总报告：可查看错误率，吞吐量等。 问题二：大量的并发和请求下redis、mysql、nginx各自会出现的问题？ &emsp;在同时并发2000的情况下（因为redis队列为异步，所以这里不考虑redis出列的性能问题）：&emsp;mysql：错误率87.9%，成功条数241。&emsp;redis：错误率0.35%，成功条数1993。&emsp;总结：从以上结果可以看出在高并发场景下msyql扛不住压力错误率高。&emsp;结论：redis在处理并发性能优于mysql。 问题三：大量的并发和请求下redis、mysql、nginx各自会出现的问题？ &emsp;3000并发循环请求3次相当于9000的次请求的情况下：&emsp;&emsp;（1）nginx报错：Too many open files（打开的文件数超过限制nginx默认为1024）。&emsp;&emsp;（2）redis报错：RDB: 2 MB of memory used by copy-on-write。&emsp;&emsp;（3）mysql直接写入失败。 问题四：遇到并发带来各种各样的问题如何解决？ &emsp;（1）nginx错误分析：最大打开文件数超过限制12345678# 查看系统打开文件值 Max open filescat /proc/`ps -ef | grep nginx|grep -v grep|head -1|awk &apos;&#123;print $2&#125;&apos;`/limits# 修改vi /etc/systemd/ststem.conf# 修改两个值DefaultLimitNOFILE = 102400DefaultLimitNPROC = 102400# 随后重启系统&emsp;（2）redis错误分析：保存频繁导致内存不够了。（暂未找到最合适的方案）&emsp;点击查看更详细的错误分析:Redis-redis异常解决以及日常命令 &emsp;（3）mysql暂没找到方案。 总结： &emsp;相同的配置&amp;高并发场景下redis比mysql要可靠很多，伴随着并发越来越高服务器、程序、数据库各方面的问题扑面而来，不要慌，这才是你真正需要学习的东西！生于忧患死于安乐，只有不断的处理问题，才能真正的驾驭程序！祝你早日成功！！！ &emsp;本文最高测试并发在3000循环次数为3次，服务器环境为lnmrp,系统配置为2核4G6M,因为redis的问题没有解决不能做更高的并发测试。并且还有一个redis的问题没有解决，待我研究几日说。","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.daichongweb.com/tags/测试/"}]},{"title":"WEB性能测试-JMeter安装","slug":"WEB性能测试-JMeter安装","date":"2019-09-17T01:55:10.000Z","updated":"2021-09-03T05:56:57.888Z","comments":true,"path":"WEB性能测试-JMeter安装/","link":"","permalink":"http://www.daichongweb.com/WEB性能测试-JMeter安装/","excerpt":"一、了解JMeter工具 &emsp;Apache JMeter是 Apache组织的开放源代码项目，是一个100%纯Java桌面应用，用于压力测试和性能测量。它最初被设计用于Web应用测试但后来扩展到其它测试领域。Apache JMeter可以用于对静态的和动态的资源（文件，Servlet，Perl脚本，Java对象，数据库和查询，FTP服务器或是其它资源）的性能进行测试。JMeter可以用于在服务器，网络或对象模拟繁重的负载来测试它们提供服务的受压能力或者分析不同压力条件下的总体性能情况。你可以使用JMeter提供的图形化界面，分析性能指标或者在高负载情况下测试你的服务器/脚本/对象。","text":"一、了解JMeter工具 &emsp;Apache JMeter是 Apache组织的开放源代码项目，是一个100%纯Java桌面应用，用于压力测试和性能测量。它最初被设计用于Web应用测试但后来扩展到其它测试领域。Apache JMeter可以用于对静态的和动态的资源（文件，Servlet，Perl脚本，Java对象，数据库和查询，FTP服务器或是其它资源）的性能进行测试。JMeter可以用于在服务器，网络或对象模拟繁重的负载来测试它们提供服务的受压能力或者分析不同压力条件下的总体性能情况。你可以使用JMeter提供的图形化界面，分析性能指标或者在高负载情况下测试你的服务器/脚本/对象。二、JMeter的作用 &emsp;（1）能够对HTTP和FTP服务器进行压力和性能测试，也可以对任何的数据库进行同样的测试（通过JDBC）。 &emsp;（2）完全多线程 框架允许通过多个线程并发取样和 通过单独的线程组对不同的功能同时取样。 &emsp;（3）在设计阶段，JMeter能够充当HTTP PROXY（代理）来记录IE/NETSCAPE的HTTP请求，也可以记录apache等WebServer的log文件来重现HTTP流量。当这些HTTP客户端请求被记录以后，测试运行时可以方便的设置重复次数和并发度（线程数）来产生巨大的流量。JMeter还提供可视化组件以及报表工具把量服务器在不同压力下的性能展现出来。 三、安装 &emsp;（1）JMeter是完全基于JAVA开发，首先要安装 JAVA JDK。 &emsp;（2）安装JMeter客户端。 四、配置JAVA环境变量 &emsp;（1）右键 “我的电脑\\属性”(第一步) 或 “控制面板\\所有控制面板项\\系统”(第一步) 找到 “高级系统设置”(第二步) 点击 “环境变量”(第三步)。 &emsp;（2）新建环境变量JAVA_HOME，值为JAVA安装的根目录。 &emsp;（3）新建环境变量CLASSPATH，值为JAVA安装目录下的lib/tools.jar和lib/dt.jar。 &emsp;（4）修改系统变量的PATH值，增加为JAVA安装目录下的bin目录。 五、配置JMeter环境变量 &emsp;（1）新建环境变量JMETER_HOME，值为JMeter的根目录。 &emsp;（2）修改CLASSPATH，增加JMeter/lib/ApacheJMeter_core.jar和logkit-2.0.jar。 &emsp;（3）找到JMeter/bin/JMeter.bat双击打开，如出现错误，检查是否有JMeter/lib/ApacheJMeter_core.jar这个文件，没有这个文件就是安装错误了，重新换个包安装。 六、打开成功演示 &emsp;随后会自动打开JMeter客户端。 七、总结 &emsp;总体的安装还是比较简单的，就是步骤繁多，每一个步骤都不能漏，否则就会无法使用。 &emsp;下一篇将会介绍JMeter的基本使用。","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.daichongweb.com/tags/测试/"}]},{"title":"消息队列（redis）-订单处理","slug":"消息队列（redis）-订单处理","date":"2019-09-16T03:20:32.000Z","updated":"2021-09-03T05:56:57.985Z","comments":true,"path":"消息队列（redis）-订单处理/","link":"","permalink":"http://www.daichongweb.com/消息队列（redis）-订单处理/","excerpt":"一、简单的介绍 &emsp;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&emsp;MySQLi是一个开源使用的 MySQL连接扩展，用于对数据库的操作和管理。&emsp;php-redis是一个开源的使用C语言编写的php扩展，用于php连接、管理redis。","text":"一、简单的介绍 &emsp;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&emsp;MySQLi是一个开源使用的 MySQL连接扩展，用于对数据库的操作和管理。&emsp;php-redis是一个开源的使用C语言编写的php扩展，用于php连接、管理redis。二、业务介绍 &emsp;某商城搞促销活动，会有大量的订单涌入数据库，每个订单15分钟未支付即为过期订单并且不能继续支付。 二、需求分析 &emsp;很显然此业务需求在不使用redis队列的情况下，大量的订单并发会造成阻塞，甚至有可能超时（php默认的超时时间为30s）。 &emsp;那么就会有以下步骤：&emsp;&emsp;（1）用户下单后把数据直接写入消息队列（list）而不是数据库，写入队列成功即返回用户成功消息。&emsp;&emsp;（2）创建订单队列：启动脚本来处理订单队列，逐一写入数据库，并设置一个key为订单号的hash过期时间为15分钟。&emsp;&emsp;（3）用户支付时首先拿这个订单号去redis里查是存在，如存在订单状态为正常状态，否则为过期状态。&emsp;&emsp;（4）订单支付成功队列：支付成功后，把订单数据写入另一个队列中，并启动脚本处理订单状态都为‘支付成功’的队列（如发送消息，修改订单状态等操作）。 &emsp;注意：这期间可能会出现数据量过大，订单创建的队列尚未执行完毕，订单支付成功后查找该订单却未找到(lpop)，那么就需要把这个未找到的订单重新添加到队列的最后（rpush）。 三、代码实现&emsp;（1）创建订单：create_order.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpinclude &quot;./RedisManager.php&quot;;/** * 模拟下单 */$post = $_POST;if (!empty($post)) &#123; // 声明状态 $status = 0; $msg = &apos;error&apos;; $order = [ &apos;order_id&apos; =&gt; &apos;HD&apos; . time(), &apos;name&apos; =&gt; $post[&apos;name&apos;] . &apos;_&apos; . $post[&apos;id&apos;], &apos;price&apos; =&gt; $post[&apos;price&apos;], &apos;date&apos; =&gt; date(&apos;Y-m-d H:i:s&apos;) ]; // 用户下单但未支付加入队列等待支付 return createOrder($order);&#125;/** * 创建订单 createOrder * * @return void */function createOrder($order)&#123; try &#123; $orderList = &apos;order:temp:list&apos;; // 临时订单列表 // 把订单写入队列 守护进程启动一个 watch_order.php 来处理订单消息 $result = RedisConnect::getRedis()-&gt;lpush($orderList, json_encode($order)); // 记录日志 if (!$result) &#123; createLog(&apos;订单写入队列失败&apos;, $order); returnMsg(&apos;订单写入队列失败&apos;); &#125; returnMsg(&apos;下单成功&apos;, $order); &#125; catch (Exception $e) &#123; createLog($e-&gt;getMessage(), $order); returnMsg($e-&gt;getMessage()); &#125;&#125;/** * 写入日志 createLog * * @param string $msg * @param array $data * @return void */function createLog(string $msg, array $data = [])&#123; $orderMsg = &apos;order:msg&apos;; // 订单消息 $data[&apos;errorMsg&apos;] = $msg; $data[&apos;errorTime&apos;] = date(&apos;Y-m-d H:i:s&apos;); RedisConnect::getRedis()-&gt;select(1); RedisConnect::getRedis()-&gt;lPush($orderMsg, json_encode($data));&#125;/** * 输出消息 returnMsg * * @param string $msg * @param array $data * @return void */function returnMsg(string $msg, array $data = [])&#123; echo json_encode([ &apos;status&apos; =&gt; 200, &apos;message&apos; =&gt; $msg, &apos;data&apos; =&gt; $data ]); exit;&#125; &emsp;（2）订单入库insert_db.php（以守护进程启动）1234567891011121314151617181920212223242526272829303132333435&lt;?phpini_set(&apos;default_socket_timeout&apos;, -1);include &apos;./RedisManager.php&apos;;include &apos;./MysqlManager.php&apos;;$orderExpire = &apos;order:temp:list&apos;;while (true) &#123; try &#123; $orderList = &apos;order:temp:list&apos;; // 临时订单列表 if (RedisConnect::getRedis()-&gt;lSize($orderList) &lt; 1) &#123; var_dump(&apos;订单已处理完毕&apos;) . &apos;\\n&apos;; sleep(1); &#125; // 处理消息 $order = RedisConnect::getRedis()-&gt;lPop($orderList); if ($order) &#123; $order = json_decode($order, true); $order_id = $order[&apos;order_id&apos;]; $name = $order[&apos;name&apos;]; $price = $order[&apos;price&apos;]; $sql = &quot;INSERT INTO `order`(`order_id`,`name`,`price`) VALUES(&apos;&#123;$order_id&#125;&apos;,&apos;&#123;$name&#125;&apos;,&#123;$price&#125;)&quot;; $result = MysqlConnect::getMysql()-&gt;query($sql); //给每一个订单设置一个过期时间 $expireResult = RedisConnect::getRedis()-&gt;hMset($orderExpire . &apos;:&apos; . $order[&apos;order_id&apos;], $order); RedisConnect::getRedis()-&gt;expire($orderExpire . &apos;:&apos; . $order[&apos;order_id&apos;], 900); var_dump($result) . &apos;\\n&apos;; &#125; else &#123; sleep(1); &#125; &#125; catch (Exception $e) &#123; echo $e-&gt;getMessage(); &#125;&#125;&emsp;（3）监听过期的订单watch_order.php（以守护进程启动）123456789101112131415161718192021222324252627&lt;?phpini_set(&apos;default_socket_timeout&apos;, -1);include &apos;./RedisManager.php&apos;;include &apos;./MysqlManager.php&apos;;RedisConnect::getRedis()-&gt;psubscribe(array(&apos;__keyevent@0__:expired&apos;), &apos;keyCallback&apos;);function keyCallback($redis, $pattern, $channel, $message)&#123; // 把过期的订单写入队列进行处理（这里可以处理为不同的订单写入不同的队列） $msgType = [ &apos;HD&apos; =&gt; &apos;home:order&apos;, // 住房订单 &apos;DD&apos; =&gt; &apos;ding:order&apos; // 餐饮订单 ]; $keyArr = explode(&apos;:&apos;, $message); $key = array_pop($keyArr); $id = substr($key, 0, 2); switch($id)&#123; case &apos;HD&apos;: $sql = &quot;UPDATE `order` SET `status` = 1 WHERE `order_id` = &apos;&#123;$key&#125;&apos;&quot;; break; &#125; $result = MysqlConnect::getMysql()-&gt;query($sql); var_dump($result);&#125;&emsp;（4）支付成功后的订单处理success_order.php（以守护进程启动）&emsp;&emsp;代码上边代码一样不做展示。 &emsp;（5）另外可增加日志队列处理来发送错误邮件给管理员send_error_mail.php（以守护进程启动）&emsp;&emsp;——————————– 四、总结 &emsp;本文只是做业务分析，未在真实的业务场景中进行实现，如有错误还请多多指正。&emsp;下一篇可能会写利用Jmeter来分析该业务代码的效率性能等问题。","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.daichongweb.com/tags/redis/"}]},{"title":"解决nginx循环重定向问题","slug":"解决nginx循环重定向问题","date":"2019-09-09T03:12:07.000Z","updated":"2021-09-03T05:56:57.987Z","comments":true,"path":"解决nginx循环重定向问题/","link":"","permalink":"http://www.daichongweb.com/解决nginx循环重定向问题/","excerpt":"一、什么是重定向、循环重定向 &emsp;（1）重定向是指浏览器先访问了服务器A，然后服务器A带着请求的参数（header、状态码3xx）返回到地址为B的服务器上。&emsp;（2）循环重定向是指服务器A重定向到了服务器B，服务器B由于某种原因又重定向到了A，这样就构成了重定向循环。 二、3xx重定向状态码 &emsp;（1）301(Move Permanently)：永久性重定向，请求的资源被分配了新的URI，以后都使用这个（get）。&emsp;（2）302(Found)：临时性重定向，请求的资源被分配了新的URI，本次使用这个（get，允许缓存）。&emsp;（3）303(See Other)：请求资源存在另一个URI，应使用get方法获取请求资源。&emsp;（4）307(Temporary Redirect)：类似于302，只是302的POST方法会变为GET，而307的不会。","text":"一、什么是重定向、循环重定向 &emsp;（1）重定向是指浏览器先访问了服务器A，然后服务器A带着请求的参数（header、状态码3xx）返回到地址为B的服务器上。&emsp;（2）循环重定向是指服务器A重定向到了服务器B，服务器B由于某种原因又重定向到了A，这样就构成了重定向循环。 二、3xx重定向状态码 &emsp;（1）301(Move Permanently)：永久性重定向，请求的资源被分配了新的URI，以后都使用这个（get）。&emsp;（2）302(Found)：临时性重定向，请求的资源被分配了新的URI，本次使用这个（get，允许缓存）。&emsp;（3）303(See Other)：请求资源存在另一个URI，应使用get方法获取请求资源。&emsp;（4）307(Temporary Redirect)：类似于302，只是302的POST方法会变为GET，而307的不会。三、怎么产生的？123456789101112server &#123; listen 80; server_name www.daichongweb.cn; root /site/hexo/public; index index.html; # 这段是产生循环重定向的原因 # 当浏览器访问 www.daichongweb.cn 时发现不是https就会进行重定向， # 但重定向到https之后又没有判断是否是https，也就是没有禁止跳转，最终造成了循环 return 301 https://$host$request_uri;&#125; 四、怎么解决？12345678910111213server &#123; listen 80; server_name www.daichongweb.cn; root /site/hexo/public; index index.html; # 通过上面的解释逻辑就变得相对简单了，只需要增加一个判断就可以解决 if ($scheme = http) &#123; return 301 https://$host$request_uri; &#125;&#125; 四、总结 &emsp;在项目开发中经常会用到重定向，认识比较常见的状态码对网络请求的判断又很大帮助。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.daichongweb.com/tags/linux/"}]},{"title":"Centos7.6搭建lnmp环境","slug":"Centos7.6搭建lnmp环境","date":"2019-09-07T09:39:48.000Z","updated":"2021-09-03T05:56:57.858Z","comments":true,"path":"Centos7.6搭建lnmp环境/","link":"","permalink":"http://www.daichongweb.com/Centos7.6搭建lnmp环境/","excerpt":"一、前言 &emsp;搭建程序运行环境是程序员必不可少的技能！&emsp;今天买了个新的云服务器，需要搭建环境，借此机会自己也熟悉了一番搭建的流程，做个日记供以后参考。&emsp;本篇大部分命令仅适合Centos7.x的系统使用。&emsp;lnmp是指Liunx、Nginx、Mysql和Php。 &emsp;目录：&emsp;（1）安装Nginx1.4。&emsp;（2）安装php7.2。&emsp;（3）安装Mariadb10.2。&emsp;（4）总结。","text":"一、前言 &emsp;搭建程序运行环境是程序员必不可少的技能！&emsp;今天买了个新的云服务器，需要搭建环境，借此机会自己也熟悉了一番搭建的流程，做个日记供以后参考。&emsp;本篇大部分命令仅适合Centos7.x的系统使用。&emsp;lnmp是指Liunx、Nginx、Mysql和Php。 &emsp;目录：&emsp;（1）安装Nginx1.4。&emsp;（2）安装php7.2。&emsp;（3）安装Mariadb10.2。&emsp;（4）总结。 二、安装Nginx &emsp;（1）防火墙设置，允许http、https通信、开启80、443、8080等端口（已开启的忽略此步骤）。123456789101112// 允许http通信firewall-cmd --zone=public --add-service=http --permanent// 允许https通信firewall-cmd --zone=public --add-service=https --permanent// 打开80端口firewall-cmd --zone-public –add-port=80/tcp --permanent // 打开443端口firewall-cmd --zone-public –add-port=443/tcp --permanent // 打开8080端口firewall-cmd --zone-public –add-port=8080/tcp --permanent // 重新加载配置firewall-cmd --reload &emsp;（2）下载依赖1yum intall pcre pcre-devel yum install pcre pcre-devel yum install zlib zlib-devel yum install openssl; openssl-devel yum install openssl;openssl-devel yum install openssl openssl-devel&emsp;（3）配置官方yum源&amp;安装Nginx123456789101112rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpmyum install nginx# 默认主配置文件：/etc/nginx/conf.d# 启动&amp;停止systemctl start/stop nginx.service# 查看服务是否启动ps aux|grep nginx# 设置服务开机自启systemctl enable nginx 注意：安装成功后无法访问，请检查防火墙设置，或在服务商后台配置安全组策略等。 二、安装php &emsp;（1）配置yum源12rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm&emsp;（2）安装php7.2及常用的扩展1yum install php72w php72w-cli php72w-common php72w-devel php72w-embedded php72w-fpm php72w-gd php72w-mbstring php72w-mysqlnd php72w-opcache php72w-pdo php72w-xml&emsp;（3）启动php-fpm123systemctl stop/start php-fpm# 设置开机启动systemctl enable php-fpm&emsp;（4）配置nginx支持phpbash123456789101112131415vim /etc/nginx/conf.d/default.conflocation / &#123; root /usr/share/nginx/html; //这是里应用目录和下面的root对应，可自定义 index index.html index.htm index.php;&#125;location ~ \\.php$ &#123; root /usr/share/nginx/html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 三、安装mariadb10.2 &emsp;（1）配置yum源123456789101112# 进入cd /usr/local/src# 下载rpm包wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm# 安装rpmrpm -ivh mysql57-community-release-el7-11.noarch.rpm# 安装 mysql-serveryum install -y mysql-server# 启动 systemctl start mysqld# 设置开机自启systemctl enable mysqld &emsp;（2）登入12345678910111213# 由于MySQL从5.7开始不允许首次安装后，使用空密码进行登录，系统会随机生成一个密码以供管理员首次登录使用，这个密码记录在/var/log/mysqld.log文件中，使用下面的命令可以查看此密码：cat /var/log/mysqld.log|grep &apos;A temporary password&apos;# 登录mysql -u root -p# 如报错 You must reset your password using ALTER USER statement before executing this statement修改密码use mysql;SET PASSWORD = PASSWORD(&apos;daichongweb&apos;); 或 ALTER USER USER() IDENTIFIED BY &apos;daichongweb&apos;;# 如报错Your password does not satisfy the current policy requirementsset global validate_password_policy=0; //修改密码验证为长度验证 四、总结 &emsp;总体来说使用yum安装比源码编译安装简单多了。&emsp;再多的理论不如真正的实践。&emsp;从出现问题，到分析问题，再到解决问题，你会从中学习到很多的知识，这也是我就算花钱也要买云服务器的原因。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.daichongweb.com/tags/linux/"}]},{"title":"php性能优化-循环优化","slug":"php性能优化-循环优化","date":"2019-08-31T02:22:30.000Z","updated":"2021-09-03T05:56:57.960Z","comments":true,"path":"php性能优化-循环优化/","link":"","permalink":"http://www.daichongweb.com/php性能优化-循环优化/","excerpt":"一、前言 &emsp;对于任何计算机程序，程序的运行性能决定了一个程序的好坏，夸张一点说程序性能的好坏直接影响了一个互联网公司的生存与发展的问题。所以对于程序员，优化性能的技能是必不可少的，就因为不会优化性能，可能就会比其他人差好几个等级。 &emsp;在PHP界，大部分互联网公司的工作内容就是最常见的CURD。你会发现自己和一些应届毕业生相比完全没有竞争优势，甚至一些公司的岗位要求也只是会CURD就行了。就像我最近找工作，不止一次的遇到面试官问：“我你觉得你的优势是什么？”，我每次都是哑口无言。","text":"一、前言 &emsp;对于任何计算机程序，程序的运行性能决定了一个程序的好坏，夸张一点说程序性能的好坏直接影响了一个互联网公司的生存与发展的问题。所以对于程序员，优化性能的技能是必不可少的，就因为不会优化性能，可能就会比其他人差好几个等级。 &emsp;在PHP界，大部分互联网公司的工作内容就是最常见的CURD。你会发现自己和一些应届毕业生相比完全没有竞争优势，甚至一些公司的岗位要求也只是会CURD就行了。就像我最近找工作，不止一次的遇到面试官问：“我你觉得你的优势是什么？”，我每次都是哑口无言。&emsp;大家都懂为了避免这样的出现，学了很多种语言。造成现在PHP岗位的要求从只会PHP语言到PHP+MYSQL+LIUNX+HTNL+CSS+JS,甚至我对面试官说：“我的优势是比其他人会的语言多！”的时候，他会回你一句：“这不是大家都会的吗？”。 &emsp;更恐怖的是，现在的PH招聘要求上都TM开始写要求熟悉JAVA、Python、Go、Golang，你TM能再过分点吗？ 二、言归正传 &emsp;在PHP中最常见的就是foreach，处理数据交际的时候一般第一时间想到的都是嵌套。 &emsp;在这我只能说尽量少用或者不使用这样的写法。 &emsp;下面介绍3种可以代替循环嵌套写法例子，并分析执行的效率和性能问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?phpini_set(&apos;memory_limit&apos;,&apos;3072M&apos;);$arr = [];$arr1 = [];for($i=1;$i&lt;=1000000;$i++)&#123; $arr[$i] = [ &apos;id&apos; =&gt; ($i+1)*2, &apos;name&apos; =&gt; &apos;戴崇_&apos;.$i ];&#125;for($j=1;$j&lt;=1000000;$j++)&#123; $arr1[$j] = [ &apos;uid&apos; =&gt;($j+1)*2, &apos;age&apos; =&gt; $j ];&#125;$t1 = microtime(true);$mode = mode1($arr,$arr1);echo &apos;&lt;br /&gt;&apos;;$t2 = microtime(true);echo $mode . &apos;耗时: &apos;.round($t2-$t1,3).&apos; 秒&lt;br /&gt;&apos;;echo &apos;内存消耗: &apos; . memory_get_usage() / 1024 / 1024 . &apos; MB&lt;br /&gt;&apos;;// 循环嵌套function mode($arr,$arr1)&#123; foreach ($arr as $k =&gt; $v) &#123; foreach ($arr1 as $key =&gt; $value) &#123; if($v[&apos;id&apos;] == $value[&apos;uid&apos;])&#123; $arr[$k][&apos;age&apos;] = $value[&apos;age&apos;]; &#125; &#125; &#125; return &apos;方法一-&gt;循环嵌套法-&gt;&apos;;&#125;// 循环拆分function mode1($arr,$arr1)&#123; $arr1 = array_index($arr1,&apos;uid&apos;); foreach ($arr as &amp;$value) &#123; if(isset($arr1[$value[&apos;id&apos;]]))&#123; $value[&apos;age&apos;] = $arr1[$value[&apos;id&apos;]][&apos;age&apos;]; &#125; &#125; return &apos;方法二-&gt;循环拆分-&gt;&apos;;&#125;// array_walk 闭包function mode2($arr,$arr1)&#123; $arr1 = array_index($arr1,&apos;uid&apos;); array_walk($arr, function(&amp;$value,$key) use ($arr1) &#123; if(isset($arr1[$value[&apos;id&apos;]]))&#123; $value[&apos;age&apos;] = $arr1[$value[&apos;id&apos;]][&apos;age&apos;]; &#125; &#125;); return &apos;方法二-&gt;array_walk 闭包-&gt;&apos;;&#125;// array_mapfunction mode3($arr,$arr1)&#123; $arr1 = array_index($arr1,&apos;uid&apos;); $arr = array_map(function(&amp;$value) use ($arr1) &#123; if(isset($arr1[$value[&apos;id&apos;]]))&#123; $value[&apos;age&apos;] = $arr1[$value[&apos;id&apos;]][&apos;age&apos;]; &#125; return $value; &#125;, $arr); return &apos;方法三-&gt;array_map-&gt;&apos;;&#125;// 把多维数组中的某个键值设置为键名function array_index(array $array, $name)&#123; $indexedArray = array(); if (empty($array)) &#123; return $indexedArray; &#125; foreach ($array as $item) &#123; if (isset($item[$name])) &#123; $indexedArray[$item[$name]] = $item; continue; &#125; &#125; return $indexedArray;&#125; &emsp;经过试验的到结果： &emsp;&emsp;(1)方法一：10000*10000（万级） 执行时间 3.377 秒 &emsp;&emsp;(2)方法二：1000000*1000000（百万级） 执行时间： 0.741 秒 0.642 秒 0.673 秒 0.609 秒 0.618 秒 &emsp;&emsp;(3)方法三：1000000*1000000（百万级） 执行时间： 0.745 秒 0.75 秒 0.664 秒 0.672 秒 0.684 秒 &emsp;&emsp;(4)方法四：1000000*1000000（百万级） 执行时间： 0.781 秒 0.803 秒 0.661 秒 0.661 秒 0.658 秒 三、总结 &emsp;在开发中一定要考虑数据量大的情况下会出现的问题，尽量使用上面的方法代替循环嵌套。另外还要注意代码风格和规范等问题。 &emsp;希望大家在看了之后能有所收获。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"php处理视频","slug":"php处理视频","date":"2019-08-29T04:47:51.000Z","updated":"2021-09-03T05:56:57.954Z","comments":true,"path":"php处理视频/","link":"","permalink":"http://www.daichongweb.com/php处理视频/","excerpt":"一、首先介绍一下这个功能的使用场景 &emsp;如优酷视频网站，某些视频的封面图就使用的这样的功能。 &emsp;大概有4种： &emsp;&emsp;(1)自有封面图（这类可能是自己手动上传的封面图，如一些宣传图）。&emsp;&emsp;(2)截取视频第一帧（可以理解为0.001秒）时的视频内容作为封面图。&emsp;&emsp;(3)截取视频某一时刻的内容作为封面图，如截取视频的第1分钟。&emsp;&emsp;(4)截取视频某一段的内容（gif）作为封面图，如截取视频的第1分20秒到1分30秒。 PS:只是单纯的拿来做例子，并不是指优酷就是使用这样的技术。","text":"一、首先介绍一下这个功能的使用场景 &emsp;如优酷视频网站，某些视频的封面图就使用的这样的功能。 &emsp;大概有4种： &emsp;&emsp;(1)自有封面图（这类可能是自己手动上传的封面图，如一些宣传图）。&emsp;&emsp;(2)截取视频第一帧（可以理解为0.001秒）时的视频内容作为封面图。&emsp;&emsp;(3)截取视频某一时刻的内容作为封面图，如截取视频的第1分钟。&emsp;&emsp;(4)截取视频某一段的内容（gif）作为封面图，如截取视频的第1分20秒到1分30秒。 PS:只是单纯的拿来做例子，并不是指优酷就是使用这样的技术。二、将会使用到的技术&emsp;(1)FFmpeg：FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。—百度百科&emsp; 注意:‘需要安装’，不同的系统安装、使用的方法不同。 &emsp;(2)PHP的Exec或System等函数（当然任何能执行外部程序的语言都能实现）。 三、Demo 12345678910111213// 安装路径$ffmpeg = &quot;C:\\\\Users\\user\\\\Desktop\\\\ffmpeg\\\\bin\\\\ffmpeg.exe&quot;;// 待处理视频的地址$video_route = &quot;D:\\\\phpstudy_pro\\\\WWW\\a.mp4&quot;;//存储地址$store_path = &quot;./2.jpg&quot;;// 把视频的前30帧截取为gifsystem($ffmpeg . &quot; -i &quot;.$video_route.&quot; -vframes 30 -y -f gif 1.gif&quot;); // 把视频的第一帧截取为图片 -r 1 表示为图宽度、高度自适应system($ffmpeg . &quot; -i &quot;.$video_route.&quot; -y -f image2 -t 0.001 -r 1 1.png&quot;); // 把视频的第8.01秒处截取为图片system($ffmpeg . &quot; -i &quot;.$video_route.&quot; -y -f image2 -ss 08.010 -t 0.001 -s 1920x1080 &quot; .$store_path. &quot;); 三、更多 &emsp;PHP+FFmpeg仅能实现这样功能吗？当然不是！还有更多的功能等待探索…&emsp;如:&emsp;&emsp;(1)视频转码。&emsp;&emsp;(2)视频加密。&emsp;&emsp;(3)视频剪切。&emsp;&emsp;(4)视频合成。&emsp;&emsp;(5)多张图片合成一个视频。&emsp;&emsp;(6)字幕。&emsp;&emsp;(7)音频处理。&emsp;&emsp;等等等….","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"php-Sphinx搜索引擎","slug":"php-Sphinx搜索引擎","date":"2019-08-16T08:33:22.000Z","updated":"2021-09-03T05:56:57.936Z","comments":true,"path":"php-Sphinx搜索引擎/","link":"","permalink":"http://www.daichongweb.com/php-Sphinx搜索引擎/","excerpt":"一、Sphinx是什么？ &emsp;是一个基于SQL的全文检索引擎，可以结合MySQL,PostgreSQL做全文搜索，它可以提供比数据库本身更专业的搜索功能，使得应用程序更容易实现专业化的全文检索。Sphinx特别为一些脚本语言设计搜索API接口，如Java，PHP，Python，Perl，Ruby等，同时为MySQL也设计了一个存储引擎插件。 —百度百科 &emsp;Sphinx 单一索引最大可包含1亿条记录，在1千万条记录情况下的查询速度为0.x秒（毫秒级）。Sphinx创建索引的速度为：创建100万条记录的索引只需 3～4分钟，创建1000万条记录的索引可以在50分钟内完成，而只包含最新10万条记录的增量索引，重建一次只需几十秒。—百度百科","text":"一、Sphinx是什么？ &emsp;是一个基于SQL的全文检索引擎，可以结合MySQL,PostgreSQL做全文搜索，它可以提供比数据库本身更专业的搜索功能，使得应用程序更容易实现专业化的全文检索。Sphinx特别为一些脚本语言设计搜索API接口，如Java，PHP，Python，Perl，Ruby等，同时为MySQL也设计了一个存储引擎插件。 —百度百科 &emsp;Sphinx 单一索引最大可包含1亿条记录，在1千万条记录情况下的查询速度为0.x秒（毫秒级）。Sphinx创建索引的速度为：创建100万条记录的索引只需 3～4分钟，创建1000万条记录的索引可以在50分钟内完成，而只包含最新10万条记录的增量索引，重建一次只需几十秒。—百度百科 二、Sphinx的特性是什么？ &emsp;高速索引 （在新款CPU上，近10 MB/秒）; 高速搜索 (2-4G的文本量中平均查询速度不到0.1秒); 高可用性 （单CPU上最大可支持100 GB的文本，100M文档）; 提供良好的相关性排名 支持分布式搜索； 提供文档摘要生成； 提供从MySQL内部的插件式存储引擎上搜索 支持布尔，短语， 和近义词查询； 支持每个文档多个全文检索域（默认最大32个）; 支持每个文档多属性； 支持断词； 支持单字节编码与UTF-8编码； 三、Sphinx安装与配置 –windows环境 &emsp;1.万物不离其宗，第一步肯定是安装啦！下载地址 —具体的安装步骤就不一一介绍了 &emsp;2.解压之后会看到 api、bin、doc、etc、misc、src 六个文件。 –windows环境可能和其他环境不同 &emsp;3.在同级目录下新建data、log两个文件。 –data:数据文件、log:检索的日志文件 &emsp;4.复制etc目录下的sphinx-min.conf.dist到bin目录修改文件名为sphinx.conf。修改配置为:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859source school # school 名字是随意起的&#123; type = mysql sql_host = localhost sql_user = root sql_pass = root sql_db = test sql_port = 3306 # 设置数据库字符集 sql_query_pre = SET NAMES utf8 # 配置数据源--也就是数据表的数据 sql_query = SELECT id, school, address FROM school # 配置返回字段--必须是数据表中存在的字段，不能设置返回主键，否则会报错 # 这里的字段还要和下面index里配置的 rt_field相对应 sql_field_string = school sql_field_string = address &#125;index school&#123; source = school # 数据源--也就是上边的名字 path = E:\\sphinx\\data\\school # 数据存放的地址--配置为刚新建的data下 mlock = 0 # 缓存内存锁定 morphology = none # 数据处理方法 min_word_len = 1 # 最小索引字长 html_strip = 0 # 是否去除html标签 ngram_len = 1 # 支持中文 ngram_chars = U+3000..U+2FA1F # 支持中文 # 字段配置 rt_attr_uint = id rt_field = school rt_field = address&#125;indexer&#123; mem_limit = 128M&#125;# 下面都是默认的 修改一下log地址就好了searchd&#123; listen = 9312 listen = 9306:mysql41 log = E:\\sphinx\\log\\searchd.log query_log = E:\\sphinx\\log\\query.log read_timeout = 5 max_children = 30 pid_file = E:\\sphinx\\log\\searchd.pid seamless_rotate = 1 preopen_indexes = 1 unlink_old = 1 workers = threads # for RT to work binlog_path = E:\\sphinx\\data&#125; 四、Sphinx在项目中如何使用呢？12345678910111213141516171819&lt;?phprequire &quot;E:\\sphinx\\api\\sphinxapi.php&quot;;$page = isset($_GET[&apos;p&apos;]) ? intval($_GET[&apos;p&apos;]) : 1;if ($page &lt;= 0) &#123; $page = 1;&#125;$pagesize = 20;$sphinxClass = new \\SphinxClient();$sphinxClass-&gt;setServer(&quot;localhost&quot;, 9312);$sphinxClass-&gt;setMaxQueryTime(3);$sphinxClass-&gt;SetArrayResult(true);$sphinxClass-&gt;SetLimits(($page - 1) * $pagesize, $pagesize, 3000); // 搜索分页// @school 表示只匹配数据表中school的字段 ,第二个参数表示使用的索引方法 对应sphinx中的index school$result = $sphinxClass-&gt;query(&apos;@school 戴崇&apos;, &apos;school&apos;);echo &apos;&lt;pre&gt;&apos;;print_r($result); 从上面代码可以看出，在项目中使用sphinx是非常简单的只需要引入这个类就ok了。 五、测试 &emsp;数据量200014条数据。 &emsp;使用mysql模糊查询平均耗时 0.130s &emsp;使用sphinx搜索引擎平均耗时 0.030s &emsp;由此可见差距是很大的，如何数据量更大的情况下差距会更大。 六、Sphinx的优点及缺点 &emsp;优点:&emsp;&emsp;(1)Sphinx索引文件每次更新都会把数据全部存储在本地，也就是说当用户使用搜索的时候并不会直接请求数据库，降低了数据库的压力。&emsp;&emsp;(2)在几十万级数据查询时，Sphinx索引速度要比数据库索引速度快上好几倍，速度快。 &emsp;缺点:&emsp;&emsp;(1)数据的索引文件会存储在本地，数据量大的时候对内存也有一定影响。&emsp;&emsp;(2)数据库的数据变化，是无法同步到Sphinx索引文件里的，也就是说每次数据库更新都要手动更新索引文件。&emsp;&emsp;(3)在没有使用中文分词的技术上，Sphinx搜索的结果是不准确的，例如：数据库中有‘戴崇1，戴崇2，戴崇3，戴崇’，使用like查询‘戴崇’会有四个结果，但使用Sphinx查询只会出现一个。 总结 &emsp;Sphinx从官网上可以看出已经将近一年没有更新过了，甚至还有一些bug没有修复，但整体来说Sphinx在使用方面还是非常简单可靠的。 &emsp;PS:下一篇将会介绍Sphinx中文分词如何使用！","categories":[],"tags":[{"name":"php扩展类","slug":"php扩展类","permalink":"http://www.daichongweb.com/tags/php扩展类/"}]},{"title":"mysql视图的使用方法","slug":"mysql视图的使用方法","date":"2019-08-15T10:48:57.000Z","updated":"2021-09-03T05:56:57.934Z","comments":true,"path":"mysql视图的使用方法/","link":"","permalink":"http://www.daichongweb.com/mysql视图的使用方法/","excerpt":"&emsp;上篇简单的介绍了视图的概念，那么这篇将告诉大家如何创建、修改、删除视图，也就是视图的基本操作了！ 一、在单表上创建视图12345678# 创建表 usercreate table user (id int,name varchar(10),age tinyint(3));# 插入数据insert into user values(1,&apos;张三&apos;,20),(2,&apos;李四&apos;,20);# 创建视图-并计算他们两年之后多少岁create view view_user as select id,name,age+2 as age from user; # 第二种写法create view view_user_1(user_id,user_name,user_age) as select id,name,age from user;","text":"&emsp;上篇简单的介绍了视图的概念，那么这篇将告诉大家如何创建、修改、删除视图，也就是视图的基本操作了！ 一、在单表上创建视图12345678# 创建表 usercreate table user (id int,name varchar(10),age tinyint(3));# 插入数据insert into user values(1,&apos;张三&apos;,20),(2,&apos;李四&apos;,20);# 创建视图-并计算他们两年之后多少岁create view view_user as select id,name,age+2 as age from user; # 第二种写法create view view_user_1(user_id,user_name,user_age) as select id,name,age from user;得到结果:idnameage1张三222李四223王二22 user_iduser_nameuser_age1张三222李四223王二22从这两种写法可以看出，在视图上是可以使用计算的，虽然两个视图中字段名不同，但数据确实相同的。因此在使用视图的时候，用户根本接触不到实际表中的结构和数据，从而保证了数据库的安全。二、在多表上创建视图12345678# 创建表 user、schoolcreate table user (id int, name varchar(10), age tinyint(3), school_id int);create table school (id int, name varchar(10));# 插入数据 insert into user values(1,&apos;张三&apos;,20,1),(2,&apos;李四&apos;,20,2);insert into school values(1,&apos;清华&apos;),(2,&apos;北大&apos;);# 创建视图create view view_user_school(user_id,user_name,user_school) as select user.id,user.name school.name from user,school where user.school_id = school.id;通过视图看到的结果：user_iduser_nameuser_school1张三清华2李四北大 三、查看视图1desc 视图名;通过这个命令可以看出视图的字段定义、字段的数据类型、是否为空、是否为主键/外键、默认值和额外信息。1select table status like &apos;视图名&apos;;通过这个命令可看出存储引擎、创建时间、Comment。1show create view &apos;视图名&apos;;通过这个命令可以看出视图的名称、创建视图的语句等信息。 四、修改视图1create or replace view view_user as select id,user,name,age from user; 1alert view view_user as select id,user,name,age from user; 五、更新视图12update view_user set age=100 where id=1;delete from view_user where id=1;当视图更新的时候相对应的基础表也会被更新，但如果是多表创建、使用了计算或者是聚合函数都是无法修改/删除成功的，并且会报错。 六、删除视图1drop view if exists view_user; 总结： &emsp;1.两者的区别 &emsp;&emsp;(1) 视图是已经编译好的sql语句，是基于sql语句的结果集形成的可视化表，而表不是。&emsp;&emsp;(2) 视图没有实际的物理记录，而表有。&emsp;&emsp;(3) 表是内容，视图是窗口。&emsp;&emsp;(4) 表占用物理空间而视图不占用。&emsp;&emsp;(5) 视图是查看数据表的一种方法，从安全角度上来说视图可以防止用户接触到数据表，使用户不知道表结构。&emsp;&emsp;(6) 表属于全局模式中的表，是实表，视图是局部模式的表，是虚表。&emsp;&emsp;(7) 视图的简历和删除只会影响到视图的本身，不影响对应表的基本数据。 &emsp;2.两者的关系 &emsp;&emsp;(1) 视图是建立在基本表纸上的表，它的结构都来源于基本表。无基本表视图将无法建立，视图是基本表的抽象和在逻辑意义上建立的新关系。","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.daichongweb.com/tags/mysql/"}]},{"title":"mysql视图介绍","slug":"mysql视图介绍","date":"2019-08-15T09:01:27.000Z","updated":"2021-09-03T05:56:57.934Z","comments":true,"path":"mysql视图介绍/","link":"","permalink":"http://www.daichongweb.com/mysql视图介绍/","excerpt":"一、视图的含义 &emsp;1.视图是从一个或多个表中导出的，视图的行为与表非常的相似，但视图是一个虚拟的表。在视图中可以使用Select语句进行查询，也可以使用Insert、Update、Delete，视图还可以从已经存在的视图的基础上定义（也就是视图上再做视图）。","text":"一、视图的含义 &emsp;1.视图是从一个或多个表中导出的，视图的行为与表非常的相似，但视图是一个虚拟的表。在视图中可以使用Select语句进行查询，也可以使用Insert、Update、Delete，视图还可以从已经存在的视图的基础上定义（也就是视图上再做视图）。&emsp;2.视图定义好之后会存在数据库中，从视图看到的数据并不是视图真正存储在数据库中的数据，通过视图看到的数据只是存放在基本表中的数据。 &emsp;3.对视图的操作和对表的操作是一样的，可以进行CURD。当修改通过视图看到的数据时，相对于的基本表的数据也会发生变化;同时，若基本表的数据发生变化，视图看到的数据也会发生变化。 二、如何理解视图与基本表的关系呢？ &emsp;有一张用户表：ID姓名年龄学校1张三20清华2李四20北大3王二20北大 &emsp;创建一个基于用户表的视图，视图里的字段只有姓名和年龄，那么他们的关系就像在这个用户表上盖了一个木板，木板上留了个窗口，从这个窗口看进去只能看见姓名和年龄，这便是视图的作用和他们的关系。 三、视图的作用 &emsp;与直接从数据表中读取数据相比，视图具有以下优点： &emsp;&emsp;(1)、简单化 &emsp;&emsp;&emsp;&emsp;：从视图看到的数据你可以自定义，也就是说看到的都是需要的数据。那些被经常使用查询的表可以创建一张视图，从而使使以后的操作不需要都假设全部的条件。 &emsp;&emsp;(2)、安全性 &emsp;&emsp;&emsp;&emsp;：假如数据表的某些字段是隐私的，不想被其他人看到。这时你就可以创建一张视图把隐私的字段过滤掉。 &emsp;&emsp;(3)、逻辑数据独立性 &emsp;&emsp;&emsp;&emsp;：视图可帮助用户屏蔽真实的表结构变化带来的影响。 PS:下篇讲介绍视图如何创建、使用等。","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.daichongweb.com/tags/mysql/"}]},{"title":"charles过滤数据包","slug":"charles过滤数据包","date":"2019-08-09T05:04:51.000Z","updated":"2021-09-03T05:56:57.909Z","comments":true,"path":"charles过滤数据包/","link":"","permalink":"http://www.daichongweb.com/charles过滤数据包/","excerpt":"1.1 设置过滤：找到【Proxy】-【Recording Setting】","text":"1.1 设置过滤：找到【Proxy】-【Recording Setting】点击Add添加过滤规则： （1）Protocol 选择过滤的协议 （2）Host 填写IP或网址 （3）Port 填写端口 *为全部端口","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://www.daichongweb.com/tags/开发工具/"}]},{"title":"charles抓ios手机数据包","slug":"charles抓ios手机数据包","date":"2019-08-09T02:57:15.000Z","updated":"2021-09-03T05:56:57.898Z","comments":true,"path":"charles抓ios手机数据包/","link":"","permalink":"http://www.daichongweb.com/charles抓ios手机数据包/","excerpt":"Charles其实是一款代理服务器，通过过将自己设置成系统（电脑或者浏览器）的网络访问代理服务器，然后截取请求和请求结果达到分析抓包的目的。该软件是用Java写的，能够在Windows，Mac，Linux上使用.","text":"Charles其实是一款代理服务器，通过过将自己设置成系统（电脑或者浏览器）的网络访问代理服务器，然后截取请求和请求结果达到分析抓包的目的。该软件是用Java写的，能够在Windows，Mac，Linux上使用.Charles的主要功能： （1）截取Http 和 Https 网络封包。 （2）支持重发网络请求，方便后端调试。 （3）支持修改网络请求参数。 （4）支持网络请求的截获并动态修改。 （5）支持模拟慢速网络。 1.1 下载安装Charles： 点击下载 1.2 设置代理模式：设置端口为8888，勾选上Enable transparency HTTP proxying 1.3 设置本机为代理：勾选为Mac local 本地代理 1.4 设置过滤协议：设置抓取协议类型 . 为全部host的所以协议端口 到此为止其实已经可以抓取到手机的数据包了，只是无法抓取https协议的数据包。 2.1 安装证书：抓https数据包，点击之后会弹出电脑证书的列表 2.2 设置信任：找到刚下载的Charles证书，双击打开，设置始终信任 3.3 获取证书下载地址 3.4 下载证书：用苹果浏览器访问chls.pro/ssl下载证书 3.5 安装证书：在【设置】-【通用】-【描述文件】中找到刚刚下载的证书，双击并安装 3.6 设置信任：在【设置】-【通用】-【关于本机】-【证书信任设置】中找到安装的证书，点击设置为信任 之后就和电脑连接同一个wifi,配置代理为电脑端的本机ip，端口为设置的8888，连接之后电脑端会弹出一个提示框，点击Allow就ok了。","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://www.daichongweb.com/tags/开发工具/"}]},{"title":"git覆盖本地未提交的代码","slug":"git覆盖本地未提交的代码","date":"2019-06-23T07:37:13.000Z","updated":"2021-09-03T05:56:57.912Z","comments":true,"path":"git覆盖本地未提交的代码/","link":"","permalink":"http://www.daichongweb.com/git覆盖本地未提交的代码/","excerpt":"&emsp;在多人协作开发中，使用git或svn管理代码最常见的问题就是代码冲突！ &emsp;作为高效开发团队中的一员应当具有处理这些问题的能力。 &emsp;假设现有一个项目，有多个开发成员，成员A和成员B共同管理同一个分支的代码。成员A在本地修改了代码并提交到daichongweb分支，成员B也修改了代码，当成员B需要用到成员A提交代码中的部分功能，需要拉取daichongweb分支的代码，这时会出现一个错误。","text":"&emsp;在多人协作开发中，使用git或svn管理代码最常见的问题就是代码冲突！ &emsp;作为高效开发团队中的一员应当具有处理这些问题的能力。 &emsp;假设现有一个项目，有多个开发成员，成员A和成员B共同管理同一个分支的代码。成员A在本地修改了代码并提交到daichongweb分支，成员B也修改了代码，当成员B需要用到成员A提交代码中的部分功能，需要拉取daichongweb分支的代码，这时会出现一个错误。&emsp;可以看出git不允许拉取代码，因为成员A也同样修改了代码。那么能提交吗？答案是不能！提交会出现代码冲突的错误！ &emsp;这时应该想到的是如何把本地代码保存起来，当然git提供了命令。1git stash&emsp;使用 git stash 可将已修改的代码保存起来，然后在使用git pull 拉取代码就不会出现错误。 &emsp;然后执行git stash list查看暂存代码，再使用git stash pop stash@{0}把代码pop出来，这时会提示冲突，把冲突解决就好了。12git stash list git stash pop stash@&#123;0&#125; 总结 代码冲突要在本地处理，不要直接提交。解决同一分支冲突的步骤：12345git stashgit pullgit stash list git stash pop stash@&#123;0&#125;解决冲突","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://www.daichongweb.com/tags/git/"}]},{"title":"【原创】phpgd库处理图片生成海报图","slug":"phpgd库处理图片生成海报图","date":"2019-05-23T10:14:12.000Z","updated":"2021-09-03T05:56:57.946Z","comments":true,"path":"phpgd库处理图片生成海报图/","link":"","permalink":"http://www.daichongweb.com/phpgd库处理图片生成海报图/","excerpt":"一.引言 &emsp;好久没写博客了，不知道该写些什么。&emsp;正发愁呢，突然发现了一个好玩的东西。&emsp;是什么呢？是php的一个扩展GD库。 &emsp;为什么说他好玩？因为GD库就像一个图片处理器，它可以组合图片、剪辑图片等等…. &emsp;后来经过整理和实践发现，这个东西比较适合做产品推广图来用，更加适合在公众号或小程序里跟二维码结合起来使用。","text":"一.引言 &emsp;好久没写博客了，不知道该写些什么。&emsp;正发愁呢，突然发现了一个好玩的东西。&emsp;是什么呢？是php的一个扩展GD库。 &emsp;为什么说他好玩？因为GD库就像一个图片处理器，它可以组合图片、剪辑图片等等…. &emsp;后来经过整理和实践发现，这个东西比较适合做产品推广图来用，更加适合在公众号或小程序里跟二维码结合起来使用。二.简单介绍 &emsp;1).如何下载类库&amp;&amp;测试demo，大家可以从github上拉取，地址：类库&&demo&emsp;2).如何使用1234&lt;?phpuse \\CreatePoster\\CreateHelper;require &apos;./gd.php&apos;;CreateHelper::start();&emsp;3).注意事项：&emsp;&emsp;1.写入字体要引入字体文件，文件路径一般为绝对路径。&emsp;&emsp;2.下载地址可以在load函数中配置。&emsp;&emsp;3.主图最好是png格式，这样清晰度会很高。&emsp;&emsp;4.使用CreateImage创建画板时，如果传入的图片较小，如需放大请使用第4和第5个参数。 &emsp;&emsp;5.使用CreateImage创建画板时，注意imagecolortransparent使用，他会把画板变为透明。 PS:其他的用途就看大家的创意、想法了。我们不做代码搬运工，我们要做代码艺术家。后续此类会经常的更新和优化….四.代码浏览 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360&lt;?phpnamespace CreatePoster;/** * 生成海报图 * @author daichongweb * @url daichongweb.cn,daichongweb.com */class CreateHelper&#123; public static function start() &#123; echo (&apos;&lt;h2&gt;欢迎使用：)&lt;/h2&gt;&apos;); echo &apos;&lt;hr /&gt;&apos;; echo &apos;海报图制作步骤:&apos;; echo &apos;&lt;br /&gt;&apos;; echo &apos;&lt;br /&gt;&apos;; echo &apos;&amp;emsp;&amp;emsp;1.创建画板(普通画板用CreatePalette;图像画板用CreateImage)&apos;; echo &apos;&lt;br /&gt;&apos;; echo &apos;&amp;emsp;&amp;emsp;2.合并图片(ImagesMerge)&apos;; echo &apos;&lt;br /&gt;&apos;; echo &apos;&amp;emsp;&amp;emsp;3.插入文字(CreateChars)&apos;; echo &apos;&lt;br /&gt;&apos;; echo &apos;&amp;emsp;&amp;emsp;4.插入划线(CreateLine)&apos;; echo &apos;&lt;br /&gt;&apos;; echo &apos;&amp;emsp;&amp;emsp;5.下载或查看&apos;; echo &apos;&lt;br /&gt;&apos;; echo (&apos;&lt;h2&gt;注意事项:&lt;/h2&gt;&apos;); echo &apos;&lt;hr /&gt;&apos;; echo &quot;&lt;font color=&apos;red&apos;&gt;注意事项：主图尽量改为png格式，这样的话图片会很清晰，在浏览器中直接查看效果不是很好，下载下来就会很清晰的。&lt;/font&gt;&quot;; &#125; /** * [CreatePalette 新建一个画板] * @param array $config 数据配置 * @param int $x_size 画板的宽度 * @param int $y_size 画板的高度 * @param int $red 红色 * @param int $green 绿色 * @param int $blue 蓝色 */ public static function CreatePalette($config) &#123; $Palette = imagecreate($config[&apos;x_size&apos;], $config[&apos;y_size&apos;]); imagecolorallocate($Palette, $config[&apos;red&apos;], $config[&apos;green&apos;], $config[&apos;blue&apos;]); return $Palette; &#125; /** * [OrthogonBr 画一个矩形边框] * @param resource $mainBg 画布资源 * @param array $config 数据配置 * @param int $x1 x坐标 * @param int $y1 y坐标 * * @param int $red 红色 * @param int $green 绿色 * @param int $blue 蓝色 */ public static function OrthogonBr($mainBg, $config) &#123; $color = imagecolorallocate($mainBg, $config[&apos;red&apos;], $config[&apos;green&apos;], $config[&apos;blue&apos;]); imagerectangle($mainBg, $config[&apos;x1&apos;], $config[&apos;y1&apos;], $config[&apos;x2&apos;], $config[&apos;y2&apos;], $color); &#125; /** * [OrthogonBg 画一个矩形实体] * @param resource $mainBg 画布资源 * @param array $config 数据配置 * @param int $x1 x坐标 * @param int $y1 y坐标 * * @param int $red 红色 * @param int $green 绿色 * @param int $blue 蓝色 */ public static function OrthogonBg($mainBg, $config) &#123; $color = imagecolorallocate($mainBg, $config[&apos;red&apos;], $config[&apos;green&apos;], $config[&apos;blue&apos;]); imagefilledrectangle($mainBg, $config[&apos;x1&apos;], $config[&apos;y1&apos;], $config[&apos;x2&apos;], $config[&apos;y2&apos;], $color); &#125; /** * [CircleBr 画一个椭圆边框] * @param resource $mainBg 画布资源 * @param array $config 数据配置 * @param int $left 距离左边的距离 * @param int $top 距离上边的距离 * @param int $width 宽度 * @param int $height 高度 * @param int $red 红色 * @param int $green 绿色 * @param int $blue 蓝色 */ public static function CircleBr($mainBg, $config) &#123; $color = imagecolorallocate($mainBg, $config[&apos;red&apos;], $config[&apos;green&apos;], $config[&apos;blue&apos;]); imageellipse($mainBg, $config[&apos;left&apos;], $config[&apos;top&apos;], $config[&apos;width&apos;], $config[&apos;height&apos;], $color); &#125; /** * [CircleBg 画一个实体椭圆] * @param resource $mainBg 画布资源 * @param array $config 数据配置 * @param int $left 距离左边的距离 * @param int $top 距离上边的距离 * @param int $width 宽度 * @param int $red 红色 * @param int $green 绿色 * @param int $blue 蓝色 */ public static function CircleBg($mainBg, $config) &#123; $color = imagecolorallocate($mainBg, $config[&apos;red&apos;], $config[&apos;green&apos;], $config[&apos;blue&apos;]); imagefilledellipse($mainBg, $config[&apos;left&apos;], $config[&apos;top&apos;], $config[&apos;width&apos;], $config[&apos;height&apos;], $color); &#125; /** * [StarBr 画一个五角星边框] * @param resource $mainBg 画布资源 * @param array $config 数据配置 * @param int $r 半径 * @param int $left 距离左边的距离 * @param int $top 距离上边的距离 */ public static function StarBr($mainBg, $config) &#123; $r = $config[&apos;r&apos;]; $degree36 = deg2rad(36); $l = 2 * $r * sin($degree36); $a = $l * cos($degree36); $b = $l * sin($degree36); $c = $l / 2; $d = $r * cos($degree36); $px1 = $config[&apos;left&apos;]; $py1 = $config[&apos;top&apos;]; $px2 = $px1 + $a; $py2 = $py1 + $b; $px3 = $px1 + $c; $py3 = $py1 + $r + $d; $px4 = $px1 - $c; $py4 = $py1 + $r + $d; $px5 = $px1 - $a; $py5 = $py1 + $b; $color = imagecolorallocate($mainBg, $config[&apos;red&apos;], $config[&apos;green&apos;], $config[&apos;blue&apos;]); imageline($mainBg, $px2, $py2, $px5, $py5, $color); imageline($mainBg, $px1, $py1, $px3, $py3, $color); imageline($mainBg, $px1, $py1, $px4, $py4, $color); imageline($mainBg, $px2, $py2, $px4, $py4, $color); imageline($mainBg, $px3, $py3, $px5, $py5, $color); &#125; /** * [CreateImage 新建一个图像画板] * @param url $palette 图像的地址 * @param string $dst_w 目标图片的宽度 * @param string $dst_h 目标图片的高度 * @param string $bgWidth 画板的宽度 * @param string $bgHeight 画板的高度 这两项决定了图片如果小了是否会被拉伸 */ public static function CreateImage($palette, $dst_w = &apos;&apos;, $dst_h = &apos;&apos;, $bgWidth = &apos;&apos;, $bgHeight = &apos;&apos;) &#123; $info = getimagesize($palette); $backgroundFun = &apos;imagecreatefrom&apos; . image_type_to_extension($info[2], false); $background = $backgroundFun($palette); $backgroundWidth = imagesx($background); $backgroundHeight = imagesy($background); $imageRes = imageCreatetruecolor($bgWidth ? $bgWidth : $backgroundWidth, $bgHeight ? $bgHeight : $backgroundHeight); $color = imagecolorallocate($imageRes, 255, 255, 255); // 正式使用 这个定要注释 // imagecolortransparent($imageRes, $color); imagefill($imageRes, 0, 0, $color); imagecopyresized($imageRes, $background, 0, 0, 0, 0, $dst_w ? $dst_w : imagesx($background), $dst_h ? $dst_h : imagesy($background), imagesx($background), imagesy($background)); return $imageRes; &#125; /** * [CreateChars 在画板中插入文字] * @param resource $image 图片源 * @param array $config 配置信息 * @param int $red 红色 * @param int $green 绿色 * @param int $blue 蓝色 * @param int $num 次数越多文字越粗 * @param int $size 文字大小 * @param int $angle 旋转的角度 默认不旋转为0 * @param int $x 文字的坐标x * @param int $y 文字的坐标y * @param int $font 字体文件 这里一般为绝对路径 * @param int $text 文字内容 * */ public static function CreateChars($image, $config) &#123; //设置文字颜色 $color = imagecolorexactalpha($image, $config[&apos;red&apos;], $config[&apos;green&apos;], $config[&apos;blue&apos;], $config[&apos;alpha&apos;]); //循环多次为了加粗字体 for ($i = 1; $i &lt;= $config[&apos;num&apos;]; $i++) &#123; imagettftext($image, $config[&apos;size&apos;], $config[&apos;angle&apos;], $config[&apos;x&apos;], $config[&apos;y&apos;], $color, $config[&apos;font&apos;], $config[&apos;text&apos;]); &#125; return $image; &#125; /** * [CreateLine 画一条实线] * @param resource $image 图片源 * @param array $config 数据配置 * @param int $red 红色 * @param int $green 绿色 * @param int $blue 蓝色 * @param int $alpha 透明度 0不透明 * @param int $x1 x2 坐标x * @param int $y1 y2 坐标y */ public static function CreateLine($image, $config) &#123; //设置线条颜色 $color = imagecolorexactalpha($image, $config[&apos;red&apos;], $config[&apos;green&apos;], $config[&apos;blue&apos;], $config[&apos;alpha&apos;]); //划线 imageline($image, $config[&apos;x1&apos;], $config[&apos;y1&apos;], $config[&apos;x2&apos;], $config[&apos;y2&apos;], $color); return $image; &#125; /** * [functionName 图片合并] * 将 src_im 图像中坐标从 src_x，src_y 开始，宽度为 src_w，高度为 src_h 的一部分拷贝到 dst_im 图像中坐标为 dst_x 和 dst_y 的位置上。两图像将根据 pct * 来决定合并程度，其值范围从 0 到 100。当 pct = 0 时，实际上什么也没做，当为 100 时对于调色板图像本函数和 imagecopy() 完全一样，它对真彩色图像实现了 alpha * * 透明。 * @return */ public static function ImagesMerge($mainBg, $second, $config) &#123; imagecopymerge($mainBg, $second, $config[&apos;dst_x&apos;], $config[&apos;dst_y&apos;], $config[&apos;src_x&apos;], $config[&apos;src_y&apos;], $config[&apos;src_w&apos;], $config[&apos;src_h&apos;], $config[&apos;pct&apos;]); &#125; /** * [AutoWrap 文字换行] * @param int $fontsize 字体大小 * @param int $angle 角度大小 * @param int $fontface 字体文件 * @param string $string 文字内容 * @param width $width 最大宽度 也就是达到这个宽度之后会换行 */ public static function AutoWrap($fontsize, $angle, $fontface, $string, $width) &#123; $content = &quot;&quot;; // 将字符串拆分成一个个单字 保存到数组 letter 中 for ($i = 0; $i &lt; mb_strlen($string); $i++) &#123; $letter[] = mb_substr($string, $i, 1); &#125; foreach ($letter as $l) &#123; $teststr = $content . &quot;&quot; . $l; $testbox = imagettfbbox($fontsize, $angle, $fontface, $teststr); // 判断拼接后的字符串是否超过预设的宽度 if (($testbox[2] &gt; $width) &amp;&amp; ($content !== &quot;&quot;)) &#123; $content .= &quot;\\n&quot;; &#125; $content .= $l; &#125; $content = mb_convert_encoding($content, &quot;html-entities&quot;, &quot;utf-8&quot;); return $content; &#125; /** * [getInfo 获取图片信息] * @param url $name 图片地址 * @return array */ public static function getInfo($name) &#123; $info = getimagesize($name); $width = $info[0]; $height = $info[1]; $mime = $info[&apos;mime&apos;]; switch ($mime) &#123; case &apos;image/jpeg&apos;: $res = imagecreatefromjpeg($name); break; case &apos;image/gif&apos;: $res = imagecreatefromgif($name); break; case &apos;image/png&apos;: $res = imagecreatefrompng($name); break; case &apos;image/wbmp&apos;: $res = imagecreatefromwbmp($name); break; &#125; return array(&apos;width&apos; =&gt; $width, &apos;height&apos; =&gt; $height, &apos;res&apos; =&gt; $res); &#125; /** * [look 在浏览器中显示图片] * @param resource $imageRes 图片源 * @return */ public static function look($imageRes) &#123; header(&quot;Content-type:image/png&quot;); imagejpeg($imageRes); imagedestroy($imageRes); &#125; /** * [load 下载图片] * @param resource $img 图片源 * @param url $name 主图地址 * @return */ public static function load($img, $name) &#123; $info = self::getInfo($name); $ext = pathinfo($name, PATHINFO_EXTENSION); $file_path = &apos;./&apos; . date(&apos;Y-m-d&apos;); if (!file_exists($file_path)) &#123; mkdir($file_path, 0777, true); &#125; $rand_name = $file_path . &apos;/&apos; . md5(mt_rand() . time()) . &quot;.&quot; . $ext; switch ($ext) &#123; case &apos;jpg&apos;: case &apos;jpeg&apos;: case &apos;jpe&apos;: imagejpeg($img, $rand_name); break; case &apos;png&apos;: imagepng($img, $rand_name); break; case &apos;gif&apos;: imagegif($img, $rand_name); break; case &apos;bmp&apos;: case &apos;wbmp&apos;: imagewbmp($img, $rand_name); break; &#125; //销毁资源 imagedestroy($info[&apos;res&apos;]); imagedestroy($img); &#125;&#125;","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"使用htpasswd为web网站增加安全性","slug":"使用htpasswd为web网站增加安全性","date":"2019-05-13T07:34:52.000Z","updated":"2021-09-03T05:56:57.975Z","comments":true,"path":"使用htpasswd为web网站增加安全性/","link":"","permalink":"http://www.daichongweb.com/使用htpasswd为web网站增加安全性/","excerpt":"一.引言 什么是 htpasswd ?&emsp;(1)htpasswd是开源 http 服务器apache httpd的一个命令工具，用于生成 http 基本认证的密码文件。&emsp;(2)nginx底层提供了 HttpAuthBasic模块，这个模块支持最基本的http认证，这是http协议支持的。当你访问网站时候会弹出一个对话框要求你输入账号密码,只要输入正确才能访问对应的网站。如果认证失败会怎么样 ?","text":"一.引言 什么是 htpasswd ?&emsp;(1)htpasswd是开源 http 服务器apache httpd的一个命令工具，用于生成 http 基本认证的密码文件。&emsp;(2)nginx底层提供了 HttpAuthBasic模块，这个模块支持最基本的http认证，这是http协议支持的。当你访问网站时候会弹出一个对话框要求你输入账号密码,只要输入正确才能访问对应的网站。如果认证失败会怎么样 ?这样做的目的是什么 ?&emsp;(1)为了禁止访问特殊的网页(这里暂时还没了解到特殊的用法…之后再补充)&emsp;(2)是的,我用这个的原因是为walle项目安全考虑的,因为walle官方推荐为了安全尽量放在内网(这里应该是为了防止暴力破解),之前的的博文也有讲到可以使用双向认证,但是对初学者而言是很不友好、有点麻烦的,那么这个htpasswd就非常之简单了，就是敢敢单单。哎！坐下坐下这是基操。二.安装&amp;&amp;配置 &emsp;第一步:检测是否已经安装了 httpd123456#httpd -vServer version: Apache/2.4.6 (CentOS)Server built: Apr 24 2019 13:45:48#没安装的执行#yum -y install httpd &emsp;第二步:创建用户123456#这里必须是nginx的安装目录.passwd后面是 账号 密码#htpasswd -bc /etc/nginx/.passwd daichongweb daichongweb#生成成功:Adding password for user daichongweb#注意:不同的机子可能nginx下的文件不同有的人是.htpasswd&emsp;第三步:nginx配置1234location / &#123; auth_basic &quot;这里随意起个名字&quot;; auth_basic_user_file /etc/nginx/.passwd;#这里是nginx安装目录下的密码文件&#125;&emsp;第四步:检测配置&amp;&amp;重启服务1234567#nginx -t#nginx: the configuration file /etc/nginx/nginx.conf syntax is ok#nginx: configuration file /etc/nginx/nginx.conf test is successful#重启#nginx -s reload&emsp;第五步:访问域名测试三.其他操作 123456789101112131415#删除用户#htpasswd -D /etc/nginx/.passwd daichongweb#修改密码#htpasswd -d /etc/nginx/.passwd daichongweb123#其他命令-c：创建一个加密文件-n：不更新加密文件，只将加密后的用户名密码显示在屏幕上-m：默认采用MD5算法对密码进行加密-d：采用CRYPT算法对密码进行加密-p：不对密码进行进行加密，即明文密码-s：采用SHA算法对密码进行加密-b：在命令行中一并输入用户名和密码而不是根据提示输入密码-D：删除指定的用户本篇文章到这里就结束了，感谢大家的支持！","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.daichongweb.com/tags/linux/"}]},{"title":"【原创】用jquery做爬虫","slug":"用jquery做爬虫","date":"2019-05-10T03:34:38.000Z","updated":"2021-09-03T05:56:57.985Z","comments":true,"path":"用jquery做爬虫/","link":"","permalink":"http://www.daichongweb.com/用jquery做爬虫/","excerpt":"引言 &emsp;之前公司有需求要做一个采集信息的工具,包括获取商品信息导入数据库,比价什么的功能,没办法只能尝试这做一下。&emsp;考虑到是做定向爬取,我就选择了jquery,因为jquery相比其他语言做爬虫是简单轻松很多。不同语言自然会有不同用处。离开环境谈哪个好，哪个不好都是耍流氓。1，如果是自己做着玩的话，定向爬几个页面，效率不是核心要求的话，问题不会大，什么语言都行的，性能差异不会大。当然，如果碰到十分复杂的页面，正则写的很复杂的话，爬虫的可维护性就会下降。","text":"引言 &emsp;之前公司有需求要做一个采集信息的工具,包括获取商品信息导入数据库,比价什么的功能,没办法只能尝试这做一下。&emsp;考虑到是做定向爬取,我就选择了jquery,因为jquery相比其他语言做爬虫是简单轻松很多。不同语言自然会有不同用处。离开环境谈哪个好，哪个不好都是耍流氓。1，如果是自己做着玩的话，定向爬几个页面，效率不是核心要求的话，问题不会大，什么语言都行的，性能差异不会大。当然，如果碰到十分复杂的页面，正则写的很复杂的话，爬虫的可维护性就会下降。2，如果是做定向爬取，而目标又要解析动态js。那么这个时候，用普通的请求页面，然后得到内容的方法肯定不行了，就要一个类似firfox，chrome的js引擎来对js代码做动态解析。这个时候推荐casperJS+phantomjs或slimerJS+phantomjs 3，如果是大规模的网站爬取。这个时候就要考虑到，效率，扩展性，可维护性，等等了。大规模的爬取涉及的方面很多，比如分布式爬取，判重机制，任务调度。这些问题深入下去哪一个简单了？语言选取这个时候很重要。NodeJs：做爬虫效率很高。高并发，多线程编程变成了简单的遍历和callback，内存cpu占用小，要处理好callback。 PHP：各种框架到处有，随便拉个来用都行。但是，PHP的效率真的有问题…不多说Python:我用python写的比较多，对各种问题都有比较好的支持。scrapy框架很好用，优点多。我觉得js也不是很适合写…效率问题。没写过，估计会有麻烦一堆。据我知道的，大公司也有用c++的，总之大多数都是在开源框架上改造。真重新造个轮子的不多吧。不值。 来自segmentfault一位大佬jquery实现 抓取代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899javascript: (function() &#123; try &#123; var Arr = &#123; &apos;name&apos;: getTitle(), &apos;img&apos;: getImgs(), &apos;price&apos;: getPirce(), &apos;sku&apos;: getSku(), &apos;desc&apos;: getDesc(), &#125;; //获取图片 function getImgs() &#123; var imgArr = []; $(&quot;#dt-tab ul li&quot;).each(function(k, v) &#123; var imgJson = JSON.parse($(v).attr(&apos;data-imgs&apos;)); if (imgJson) &#123; imgArr.push(imgJson.preview); &#125;; &#125;); return imgArr; &#125;; //获取名称 function getTitle() &#123; var _this = $(&apos;#mod-detail-title .d-title&apos;); return _this.html(); &#125;; //获取价格 function getPirce() &#123; var _this = $(&quot;#mod-detail-price .price .ladder-3-1&quot;); var priceJson = JSON.parse(_this.attr(&apos;data-range&apos;)); return priceJson.price; &#125;; //获取sku属性 function getSku() &#123; var skuArr = []; var _this = $(&quot;.obj-sku .table-sku tr&quot;); if (_this) &#123; var step = 0; _this.each(function(k, v) &#123; step++; skuArr.push(&#123; &apos;sku_name&apos;: $(v).find(&apos;.name span&apos;).html(), &apos;price&apos;: $(v).find(&apos;.price span .value&apos;).html(), &apos;img&apos;: getSkuImg(step), &#125;); &#125;); &#125;; return skuArr; &#125;; //获取商品详情 function getDesc() &#123; var descArr = []; var _this = $(&quot;#mod-detail-description img&quot;); if (_this) &#123; _this.each(function(k, v) &#123; var url = $(v).attr(&apos;src&apos;); var patt = new RegExp(&quot;[a-zA-z]+://[^\\s]*&quot;); if(patt.test(url))&#123; descArr.push(url); &#125; &#125;); &#125;; return descArr; &#125;; //获取sku图片 function getSkuImg(step) &#123; if ($(&quot;#dt-tab ul li&quot;) &amp;&amp; $(&quot;.obj-sku .table-sku tr&quot;)) &#123; return $(&quot;#dt-tab ul li:eq(&quot; + step + &quot;) .box-img img&quot;).attr(&apos;src&apos;); &#125;; return &apos;&apos;; &#125;; if(confirm(&apos;获取成功，确认要采集吗？&apos;)==true)&#123; console.log(Arr); return false; $.ajax(&#123; type:&quot;post&quot;, url:&apos;www.daichongweb.com&apos;, data:&#123; post:Arr &#125;, dataType:&apos;json&apos;, success:function(res)&#123; if(res.code==0)&#123; alert(&apos;采集成功！&apos;); &#125;else&#123; alert(res.message); &#125; &#125;,error:function(res)&#123; alert(&apos;采集失败！&apos;); &#125;,beforeSend:function(res)&#123; $(&apos;body&apos;).append(&apos;&lt;div id=&quot;daichongweb&quot; style=&quot;position:fixed;top:0;left:0;background: rgba(0, 0, 0, .5);text-align: center;line-height: 20;font-size: 30px;color: white;width:100vw;height:100vh;z-index:1000000000;&quot;&gt;采集中！&lt;/div&gt;&apos;); &#125;,complete:function(res)&#123; $(&quot;#daichongweb&quot;).remove(); &#125; &#125;); &#125; &#125; catch (err) &#123; alert(err); &#125;;&#125;)();定向商品链接->1688.com&emsp;当然了,这个采集代码不只是针对这一个商品,它可以抓取和他页面结构一样的所有商品。 PS:这里的抓取可根据自己的实际业务来改变,比如需要让页面中的轮播图切换这个才能获取,那就在抓取之前写个切换的脚本;切换一张抓取一张;怎么才能在谷歌中运行这个脚本 &emsp;方法一：直接放在控制台(这里并不推荐使用,因为公司的人不可能都懂代码,而且操作麻烦)。&emsp;方法二：在浏览器中添加书签,把代码复制到网址栏里,要采集的时候点击一下就ok了！ PS:整体运用情况看,个人觉得jquery做采集还是挺不错的。当然相比php、python的话显得有点低端的感觉,那也没办法谁让php、python是动态获取的呢?之后会用php或python做个一个动态抓取的脚本,当然也包括比价之类的运用…..后端处理数据(可忽略) php处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245&lt;?phprequire_once './oss/autoload.php';use OSS\\OssClient;use OSS\\Core\\OssException;header('Content-Type: text/html;charset=utf-8');header('Access-Control-Allow-Origin:*'); // *代表允许任何网址请求header('Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE'); // 允许请求的类型header('Access-Control-Allow-Credentials: true'); // 设置是否允许发送 cookiesheader('Access-Control-Allow-Headers: Content-Type,Content-Length,Accept-Encoding,X-Requested-with, Origin');if($_POST)&#123; $post = $_POST['post']; if($post)&#123; //处理大图 $imgArr = $post['img']; if($imgArr)&#123; foreach ($imgArr as $k =&gt; $v) &#123; $name = saveImgToLocal($v); $ossPath = 'collect/'.date('Ym').'/'.$name; uploadImgOss($ossPath,'./img/'.$name); $imgArr[$k] = $ossPath; &#125; $post['img'] = $imgArr; &#125; if(array_key_exists('sku', $post))&#123; //处理小图 $sku = $post['sku']; if($sku)&#123; foreach ($sku as $k =&gt; $v) &#123; $name = saveImgToLocal($v['img']); $ossPath = 'collect/'.date('Ym').'/'.$name; uploadImgOss($ossPath,'./img/'.$name); $sku[$k]['img'] = $ossPath; &#125; $post['sku'] = $sku; &#125; &#125; if(array_key_exists('desc', $post))&#123; //处理详情图 $desc = $post['desc']; if($desc)&#123; foreach ($desc as $k =&gt; $v) &#123; $name = saveImgToLocal($v); $ossPath = 'collect/'.date('Ym').'/'.$name; uploadImgOss($ossPath,'./img/'.$name); $desc[$k] = $ossPath; &#125; $post['desc'] = $desc; &#125; &#125; &#125; //连接数据库 $Db = mysqli_connect(\"127.0.0.1\",\"root\",\"daichongweb\",\"shop\"); if (mysqli_connect_errno($Db)) &#123; echo \"连接 MySQL 失败: \" . mysqli_connect_error(); &#125; insertDb($Db,$post); &#125;//保存图片到本地function saveImgToLocal($telefile,$path='./img/')&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $telefile); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 120); $file = curl_exec($ch); curl_close($ch); $filename = pathinfo($telefile, PATHINFO_BASENAME); $resource = fopen($path . $filename, 'a'); fwrite($resource, $file); fclose($resource); return $filename;&#125;//上传图片的ossfunction uploadImgOss($object,$filePath)&#123; $accessKeyId = \"阿里ossKeyID\"; $accessKeySecret = 阿里ossKeySecret; $endpoint = \"项目地址\"; $bucket = \"项目名称\"; try&#123; $ossClient = new OssClient($accessKeyId, $accessKeySecret, $endpoint); $ossClient-&gt;uploadFile($bucket, $object, $filePath); &#125; catch(OssException $e) &#123; print_r($e-&gt;getMessage()); exit; &#125;&#125;/*** 获得随机字符串* @param $len 需要的长度* @param $special 是否需要特殊符号* @return string 返回随机字符串*/function getRandomStr($len, $special = false)&#123; $chars = array( \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\" ); if($special)&#123; $chars = array_merge($chars, array( \"!\", \"@\", \"#\", \"$\", \"?\", \"|\", \"&#123;\", \"/\", \":\", \";\", \"%\", \"^\", \"&amp;\", \"*\", \"(\", \")\", \"-\", \"_\", \"[\", \"]\", \"&#125;\", \"&lt;\", \"&gt;\", \"~\", \"+\", \"=\", \",\", \".\" )); &#125; $charsLen = count($chars) - 1; shuffle($chars); //打乱数组顺序 $str = ''; for($i=0; $i&lt;$len; $i++)&#123; $str .= $chars[mt_rand(0, $charsLen)]; //随机取出一位 &#125; return $str;&#125;//把数据插入数据库function insertDb($Db,$data)&#123; //商品主表 $pd_product_field = [ 'product_art_no' =&gt; '', 'product_number' =&gt; getRandomStr(32), 'pd_name' =&gt; $data['name'], 'pd_subtitle' =&gt;'', 'pd_descs' =&gt; '', 'pd_category_id' =&gt; 0, 'pd_seller_id' =&gt; 0, 'pd_brand_id' =&gt; 0, 'express_tpl_id' =&gt; 0, 'meun_id' =&gt; 0, 'pd_unit' =&gt; '', 'pd_weight' =&gt; 0, 'pd_weight_unit' =&gt; '', 'pd_volume' =&gt; 0, 'pd_volume_unit' =&gt; '', 'min_price' =&gt; 0, 'market_price' =&gt; 0, 'cost_price'=&gt; 0, 'detail_descr' =&gt; '', 'pd_key_word' =&gt; '', 'pd_remark' =&gt; '', 'pd_picture_prefix' =&gt; '', 'pd_detail_info' =&gt; '', 'detail_title' =&gt; '', 'created_at' =&gt; date('Y-m-d H:i:s'), ]; $pd_detail_info = ''; foreach ($data['desc'] as $k =&gt; $v) &#123; $pd_detail_info .= '&lt;img src=\"'.$v.'\"&gt;'; &#125; $pd_product_field['pd_detail_info'] = addslashes(bin2hex(gzcompress($pd_detail_info))); $pd_product_field['pd_image_url'] = implode(',',$data['img']); $pd_product_field['pd_translation_pic'] = implode(',',$data['img']); $pd_product_keys = ''; $pd_product_values = ''; foreach ($pd_product_field as $key =&gt; $value) &#123; $pd_product_keys .= $key.','; $pd_product_values .= \"'\".$value.\"'\".','; &#125; $pd_product_keys = trim($pd_product_keys,','); $pd_product_values = trim($pd_product_values,','); $inser_pd_product = \"insert into pd_product($pd_product_keys) value($pd_product_values)\"; mysqli_autocommit($Db,false);//开启事务 try &#123; $product_number = $pd_product_field['product_number']; $pd_product_reslut = mysqli_query($Db,$inser_pd_product); $product_id = mysqli_insert_id($Db); $pd_sku_result = 0; $pd_sku_properties_reslut = 0; $sku_unique_code = getRandomStr(32); if(array_key_exists('sku',$data) &amp;&amp; count($data['sku'])&gt;0)&#123; foreach ($data['sku'] as $key =&gt; $value) &#123; $property = $value['sku_name']; $pd_price = $value['price']; $sku_picture_url = $value['img']; $insert_pd_sku = \"insert into pd_sku(sku_unique_code,product_number,property,sku_code,product_id) value('$sku_unique_code','$product_number','$property','',$product_id)\"; $pd_sku_result = mysqli_query($Db,$insert_pd_sku); $sku_id = mysqli_insert_id($Db); $insert_pd_sku_properties = \"insert into pd_sku_properties(sku_id,sku_unique_code,product_id,product_number,sku_value,pd_price,sku_picture_url,sku_code) value($sku_id,'',$product_id,'$product_number','$property','$pd_price','$sku_picture_url','')\"; $pd_sku_properties_reslut = mysqli_query($Db,$insert_pd_sku_properties); &#125; &#125;else&#123; $pd_sku_result = 1; $pd_sku_properties_reslut = 1; &#125; if($pd_product_reslut &amp;&amp; $pd_sku_result &amp;&amp; $pd_sku_properties_reslut)&#123; mysqli_commit($Db);//提交事务 $code = 0; $message = '插入成功'; &#125;else&#123; mysqli_rollback($Db);//回滚 $code = 1; $message = '插入失败'; &#125; &#125; catch (\\Exception $e) &#123; mysqli_rollback($Db);//回滚 $code = 1; $message = $e-&gt;getMessage(); &#125; //删除本地下载的图片 foreach ($data['img'] as $key =&gt; $value) &#123; $arr = explode('/',$value); unlink('./img/'.array_pop($arr)); &#125; if(array_key_exists('desc', $data))&#123; foreach ($data['desc'] as $key =&gt; $value) &#123; $arr = explode('/',$value); unlink('./img/'.array_pop($arr)); &#125; &#125; if(array_key_exists('sku', $data))&#123; foreach ($data['sku'] as $key =&gt; $value) &#123; $arr = explode('/',$value['img']); unlink('./img/'.array_pop($arr)); &#125; &#125; echo json_encode([ 'code' =&gt; $code, 'message' =&gt; $message ]);&#125;","categories":[],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://www.daichongweb.com/tags/jquery/"}]},{"title":"【原创】walle配置或部署可能会遇到的小问题","slug":"walle配置或部署可能会遇到的小问题","date":"2019-05-09T08:16:07.000Z","updated":"2021-09-03T05:56:57.969Z","comments":true,"path":"walle配置或部署可能会遇到的小问题/","link":"","permalink":"http://www.daichongweb.com/walle配置或部署可能会遇到的小问题/","excerpt":"一.引言 &emsp;作为一个刚接触walle不久的新手,在配置和部署的过程中难免会遇到一些奇奇怪怪的问题。当然排除一些本身就对Linux什么的玩的比较好的大神。&emsp;本来想多写点字凑个字数…后来想想还是算了。二.配置时 &emsp;在项目管理-新建项目里,新增项目的时候可能会出现的问题&emsp;意思是目标机最少要有一个","text":"一.引言 &emsp;作为一个刚接触walle不久的新手,在配置和部署的过程中难免会遇到一些奇奇怪怪的问题。当然排除一些本身就对Linux什么的玩的比较好的大神。&emsp;本来想多写点字凑个字数…后来想想还是算了。二.配置时 &emsp;在项目管理-新建项目里,新增项目的时候可能会出现的问题&emsp;意思是目标机最少要有一个&emsp;操作步骤&emsp;正确位置三.部署时 &emsp;部署的时候可能出现这样的错误,因为啥呢？因为你在目标机上没有创建根目录&emsp;就是这个data目录,虽然他提示说会自动生成,但是没生成…倒是那个datar能自动生成四.访问时 &emsp;访问的时候出现这个错误,就要检查一下的nginx配置是否正确&emsp;看看是否缺了下图所示,或者是端口占用、域名配置不一致的情况&emsp;如果是长时间闲置的时候也会弹出一个后台服务未启动,这个不用担心没有什么问题 PS:其他情况在walle官网上有介绍,如502/404等错误五.安全方面 &emsp;官网建议把walle部署在内网,这样应该是没有什么大问题。&emsp;这里的话推荐搞个双向认证,这个也是我研究好久的。六.最后 说起来用的频率不是很高,更多的问题还是需要长时间的使用才能发现,当然了本篇文章会持续的更新(在发现bug的前提下..)。","categories":[{"name":"liunx","slug":"liunx","permalink":"http://www.daichongweb.com/categories/liunx/"}],"tags":[{"name":"walle","slug":"walle","permalink":"http://www.daichongweb.com/tags/walle/"}]},{"title":"walle搭建项目部署系统","slug":"walle搭建项目部署系统","date":"2019-04-30T03:32:23.000Z","updated":"2021-09-03T05:56:57.967Z","comments":true,"path":"walle搭建项目部署系统/","link":"","permalink":"http://www.daichongweb.com/walle搭建项目部署系统/","excerpt":"二.前言-为什么要使用walle来管理项目 walle 让用户代码发布终于可以不只能选择 jenkins！支持各种web代码发布，php、java、python、go等代码的发布、回滚可以通过web来一键完成。walle 一个可自由配置项目，更人性化，高颜值，支持git、多用户、多语言、多项目、多环境同时部署的开源上线部署系统 引言来自walle官网 &emsp;1).个人而言,walle为我提供了一个非常方便的项目管理平台,从项目开发到项目测试再到项目上线walle为整个流程提供了一套完美的解决方案。 &emsp;2).对公司团队而言,walle为管理者提供了一个非常好的项目管理工具。对项目质量、项目的进度、程序的安全和可靠性等等都提供了一定的保障。","text":"二.前言-为什么要使用walle来管理项目 walle 让用户代码发布终于可以不只能选择 jenkins！支持各种web代码发布，php、java、python、go等代码的发布、回滚可以通过web来一键完成。walle 一个可自由配置项目，更人性化，高颜值，支持git、多用户、多语言、多项目、多环境同时部署的开源上线部署系统 引言来自walle官网 &emsp;1).个人而言,walle为我提供了一个非常方便的项目管理平台,从项目开发到项目测试再到项目上线walle为整个流程提供了一套完美的解决方案。 &emsp;2).对公司团队而言,walle为管理者提供了一个非常好的项目管理工具。对项目质量、项目的进度、程序的安全和可靠性等等都提供了一定的保障。三.正文-walle到底能做什么 &emsp;PS:walle做的工作就是当你提交代码上线的时候,他会从宿主机(walle系统所在的机器)向你配置的git地址拉取代码、打包、上传到目标机器(正式环境所在的机器)上去、然后解压成完整的项目。 问:walle仅仅只能做这些工作吗？答:1).当然不是啦!每次提交上线单(项目代码),walle都会保存一份在目标机上。当你新上线的程序发现了bug,这是你可以选择回滚代码(ai,这个就和InnoDB的事务有些相似了)。&emsp;2).相比传统的ftp和sftp部署项目,walle就更加显得安全和可靠。&emsp;3).相比jenkins,walle是由国人开发;界面、操作更加具有亲和力。&emsp;4).同样他具有相比jenkins相同的特性pre_deploy、post_deploy、pre_release、post_release等高级任务这对于大部分开发框架来说都是非常棒的一个功能。总结:walle的优点并不止这些,更多的内容需要大家亲自去发现和挖掘。四.搭建walle部署系统-官网文档 &emsp;walle本身是由Python开发,但web需要使用nginx服务;所以搭建lnmp环境是比不可少的一步。&emsp;第一步:克隆项目1git clone https://github.com/meolu/walle-web.git&emsp;第二步: 配置nginxnginx配置1234567891011121314151617181920212223242526272829303132333435363738394041upstream webservers &#123; server 0.0.0.0:5000 weight=1; # 负载设置&#125;server &#123; listen 80; server_name 你的域名或ip; # 域名设置 access_log /usr/local/nginx/logs/walle.log main; index index.html index.htm; # 日志目录 location / &#123; try_files $uri $uri/ /index.html; add_header access-control-allow-origin *; root 指定到walle项目下fe目录; # 前端代码已集成到walle-web，即walle-web/fe的绝对路径 &#125; location ^~ /api/ &#123; add_header access-control-allow-origin *; proxy_pass http://webservers; proxy_set_header X-Forwarded-Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Origin $host:$server_port; proxy_set_header Referer $host:$server_port; &#125; location ^~ /socket.io/ &#123; add_header access-control-allow-origin *; proxy_pass http://webservers; proxy_set_header X-Forwarded-Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Origin $host:$server_port; proxy_set_header Referer $host:$server_port; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; # WebScoket Support proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; &#125;&#125;&emsp;第三步: 添加hosts123vi /etc/hosts# 新增一行127.0.0.1 你的域名 # 与nginx配置一致&emsp;第四步: 安装Python 2.7 + pip。12# 切换到walle-web根目录下操作sh admin.sh init&emsp;第五步: 修改walle配置。123456789101112131415161718192021222324252627282930313233# 切换到walle-web根目录下操作vi walle/config/settings_prod.py# @TODO 是为要修改的部分# 服务启动 @TODO# HOST 修改为与 nginx server_name 一致.# 后续在web hooks与通知中用到此域名.HOST = 你的域名PORT = 5000# https True, http FalseSSL = False# 数据库设置 @TODOSQLALCHEMY_DATABASE_URI = &apos;mysql://user:password@localhost:3306/walle?charset=utf8&apos;# 本地代码检出路径（用户查询分支, 编译, 打包） #TODOCODE_BASE = 项目路径,也就是宿主机的git仓库的路径# 日志存储路径 @TODO# 默认为walle-web项目下logs, 可自定义路径, 需以 / 结尾# LOG_PATH = &apos;/var/logs/walle/&apos;LOG_PATH = os.path.join(Config.PROJECT_ROOT, &apos;logs&apos;)LOG_PATH_ERROR = os.path.join(LOG_PATH, &apos;error.log&apos;)LOG_PATH_INFO = os.path.join(LOG_PATH, &apos;info.log&apos;)LOG_FILE_MAX_BYTES = 100 * 1024 * 1024# 邮箱配置 @TODOMAIL_SERVER = &apos;smtp.exmail.qq.com&apos;MAIL_PORT = 465MAIL_USE_SSL = TrueMAIL_USE_TLS = FalseMAIL_DEFAULT_SENDER = &apos;service@walle-web.io&apos;MAIL_USERNAME = &apos;service@walle-web.io&apos;MAIL_PASSWORD = &apos;Ki9y&amp;3U82&apos;&emsp;第六步: 初始化项目。1234# 创建数据库mysql -hxx -uxx -p -e&apos;CREATE SCHEMA walle&apos;# Data Migrationsh admin.sh migration&emsp;第七步: 启动walle。12345678# 启动sh admin.sh start# 重启sh admin.sh restart # 升级sh admin.sh upgrade# Migrationsh admin.sh migration最后访问你的域名就可以访问了！12345超管：super@walle-web.io \\ Walle123所有者：owner@walle-web.io \\ Walle123负责人：master@walle-web.io \\ Walle123开发者：developer@walle-web.io \\ Walle123访客：reporter@walle-web.io \\ Walle123PS:下篇文章将会介绍如何配置项目、项目配置中可能会遇到的问题及解决办法、上线项目要注意的事项","categories":[{"name":"liunx","slug":"liunx","permalink":"http://www.daichongweb.com/categories/liunx/"}],"tags":[{"name":"walle","slug":"walle","permalink":"http://www.daichongweb.com/tags/walle/"}]},{"title":"【原创】hexo+github+coding搭建博客(绑定多域名)","slug":"hexo-github-coding搭建博客-绑定多域名","date":"2019-04-22T09:46:21.000Z","updated":"2021-09-03T05:56:57.923Z","comments":true,"path":"hexo-github-coding搭建博客-绑定多域名/","link":"","permalink":"http://www.daichongweb.com/hexo-github-coding搭建博客-绑定多域名/","excerpt":"&emsp;一.最近服务器快到期了,也突然想起之前有个网友问我怎么用hexo+github搭建个人博客,好多天没有回他,心里也总是过意不去。不论他有没有解决这个问题,现在也需要补发一篇关于hexo+github+coding搭建个人博客的文章了。 &emsp;二.也希望通过这篇博客,能让更多正处于初期阶段的同学顺利的搭建属于自己的博客;也同样适合没有编程经验的同学来亲手感觉一下编程的乐趣！","text":"&emsp;一.最近服务器快到期了,也突然想起之前有个网友问我怎么用hexo+github搭建个人博客,好多天没有回他,心里也总是过意不去。不论他有没有解决这个问题,现在也需要补发一篇关于hexo+github+coding搭建个人博客的文章了。 &emsp;二.也希望通过这篇博客,能让更多正处于初期阶段的同学顺利的搭建属于自己的博客;也同样适合没有编程经验的同学来亲手感觉一下编程的乐趣！&emsp;三.相比使用个人服务器搭建而言利用github或coding搭建博客更加省事省力又省钱,最便宜的服务器一年也需要一千左右的租赁费,而使用github、coding、码云等搭建是完全免费的,并且不用部署服务器环境,也不用担心证书的问题。第一步:hexo本地环境的搭建 ps:这里因为hexo官网有教程,我就不一一介绍了,简单介绍一下搭建流程 hexo本地搭建流程: &emsp;&emsp;1).安装git&emsp;&emsp;2).安装nodejs&emsp;&emsp;3).安装hexo 参数配置 1).首先是根目录下_config.yml文件的配置。&emsp;&emsp;1.配置导航和博客基本信息。&emsp;&emsp;2.配置部署地址123456789101112#文章生成配置#permalink: :year/:month/:day/:title/ //文章路径 原有的路径为‘daihongweb.com/2019/04/22/hexo+github+coding搭建博客(绑定多域名)’permalink: :title/ //文章路径 改为路径为‘daihongweb.com/hexo+github+coding搭建博客(绑定多域名)’ 有利于seo优化permalink_defaults:#代码部署配置deploy: type: git repo: coding: coding仓库地址,master,//master是代码分支 github: github仓库地址,master,ps:这里建议大家再本地把一切搞好之后再添部署地址，或者在本地测试的时候不要使用 hexo d 命令第二步:搭建远程仓库 1).coding建立git仓库2).获取git地址ps:这里建议大家使用https,使用ssh需要秘钥什么的比较麻烦3).github建立git仓库4).获取git地址第三步:部署项目 ps:部署的时候可能会弹出要求登录的输入框,这个第一次部署的时候输入一次,之后就不需要再输入了1).项目中执行部署项目1hexo c &amp;&amp; hexo g &amp;&amp; hexo g &amp;&amp; hexo sps:当你访问博客的时候你会发现文章内所有的图片都加载不出来,解决办法如下12345#项目根目录下_config.ymlexternal_link: truepost_asset_folder: truerelative_link: truefuture: trueps:修改之后把图片移入文章名称对应的文件夹下的img文件夹下;修改文章中引入的路径;在重新执行上边的命令就ok了第四步:开启pages服务 1).coding开启pages服务ps:coding开启之后它会自动部署一次,点击自动分配的域名地址查看是否有问题 2).github开始pages服务在下面可以找到：显示成这样就说明部署成功了！第五步:绑定个人域名，并实现多域名绑定 首先你需要购买一个域名并且已备案。1).添加解析ps:我这里是用的阿里云的,记录类型为CNAME,记录值为你github或coding的地址;所有的服务商解析都是一样的！2).对应的github绑定个人域名ps:下面勾选的是开始https,记得勾选上;之后会提示你开始失败什么的,不用担心。稍等1小时再去刷新就好了！3).coding绑定个人域名ps:绑定之后点击申请,有的时候会出现错误,暂时还没有找到解决的办法;添加绑定之后记得点击上边的部署！ 总结:问题来了,到底是怎么实现绑定多个域名的？啊哈哈,其实就是利用多个pages服务;例如现有2个域名,那么一个域名绑定coding,一个域名绑定github;并且还可以实现国外的访问分配到github上,国内的访问分配到coding上来提升访问速度！ Daichongweb.blog","categories":[{"name":"hexo","slug":"hexo","permalink":"http://www.daichongweb.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.daichongweb.com/tags/hexo/"}]},{"title":"composer 报错php_pdo_firebird.dll找不到指定模块","slug":"composer-报错php-pdo-firebird-dll找不到指定模块","date":"2019-04-04T03:57:30.000Z","updated":"2021-09-03T05:56:57.912Z","comments":true,"path":"composer-报错php-pdo-firebird-dll找不到指定模块/","link":"","permalink":"http://www.daichongweb.com/composer-报错php-pdo-firebird-dll找不到指定模块/","excerpt":"自从把php版本切换到7.0后，一旦使用composer就会出现php_pdo_firebird.dll找不到指定模块的错误，而且还不止这一个。百度查过很多资料最后都是没有解决，最后受到一篇博客的启发，尝试在php环境里卸载掉这些扩展，最后，，居然解决了？？","text":"自从把php版本切换到7.0后，一旦使用composer就会出现php_pdo_firebird.dll找不到指定模块的错误，而且还不止这一个。百度查过很多资料最后都是没有解决，最后受到一篇博客的启发，尝试在php环境里卸载掉这些扩展，最后，，居然解决了？？实际的原因是因为在PHP7中已经不再支持使用ext/mysql这个扩展了,把不支持的扩展直接给卸载掉就ok了。错误信息： 修改方法： 根据实际情况而定，我用的是phpstudy结果： 最后又试了几次，发现只要是报错什么模块找不到，就直接卸载。","categories":[{"name":"php扩展类","slug":"php扩展类","permalink":"http://www.daichongweb.com/categories/php扩展类/"}],"tags":[{"name":"composer","slug":"composer","permalink":"http://www.daichongweb.com/tags/composer/"}]},{"title":"sublime text3 不能安装插件","slug":"sublime-text3-不能安装插件","date":"2019-03-13T05:38:18.000Z","updated":"2021-09-03T05:56:57.965Z","comments":true,"path":"sublime-text3-不能安装插件/","link":"","permalink":"http://www.daichongweb.com/sublime-text3-不能安装插件/","excerpt":"用sublime的小伙伴会发现最近用Package Control安装插件的时候总会提示请前往一个地址寻求帮助的一句话。我在百度上也了解了一下，大多都说是被墙了或者是版本的问题，真实的原因还不知道是那个，不管了反正能解决就行。 解决方案：","text":"用sublime的小伙伴会发现最近用Package Control安装插件的时候总会提示请前往一个地址寻求帮助的一句话。我在百度上也了解了一下，大多都说是被墙了或者是版本的问题，真实的原因还不知道是那个，不管了反正能解决就行。 解决方案：第一步：下载channel_v3.json文件到本地 文件地址：channe_v3.json /img/channel_v3.json 第二步：修改配置 找到：打开内容添加1234&quot;channels&quot;:[ &quot;D:/PHPTutorial/channel_v3.json&quot;//文件的地址],最后关闭sublime重启，ctrl+shift+p 找个插件试试果然可以了！！","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://www.daichongweb.com/categories/开发工具/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://www.daichongweb.com/tags/sublime/"}]},{"title":"sublime Text3自动格式化php代码","slug":"sublime-Text3自动格式化php代码","date":"2019-03-07T03:21:09.000Z","updated":"2021-09-03T05:56:57.965Z","comments":true,"path":"sublime-Text3自动格式化php代码/","link":"","permalink":"http://www.daichongweb.com/sublime-Text3自动格式化php代码/","excerpt":"sublime text3很小的一个代码开发工具，但功能却很强大。开发者可安装各种插件帮助开发，提升代码质量和开发效率，相比一些HD或pS的开发工具，个人还是比较喜欢sublime。 这篇文章主要讲sublime中自动格式化php代码的插件介绍和安装配置。","text":"sublime text3很小的一个代码开发工具，但功能却很强大。开发者可安装各种插件帮助开发，提升代码质量和开发效率，相比一些HD或pS的开发工具，个人还是比较喜欢sublime。 这篇文章主要讲sublime中自动格式化php代码的插件介绍和安装配置。首先下载插件phpfmt 下载之后把文件名改为phpfmt放入：首选项-》浏览插件目录中。重启sublime。 第二步：选择首选项-》package Settings-》phpfmt-》settings-Default 点击 第三步：配置123456&#123; &quot;version&quot;: 4, &quot;php_bin&quot;:&quot;D:/PHPTutorial/php/php-7.2.1-nts/php.exe&quot;,//你的php安装路径 &quot;format_on_save&quot;:true, &quot;option&quot;: &quot;value&quot;&#125; 保存之后重启，按ctrl+s就会自动格式化了，然后格式化的还是不美观。 那么下一步选择PSR2，按住ctrl+shift+p，输入phpfmt: toggle PSR2 回车，在测试你就会发现格式漂亮了许多。 注意：ctrl+shift+p无法使用是需要安装package Control 百度搜一下教程，这里就不一一介绍了","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://www.daichongweb.com/categories/开发工具/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://www.daichongweb.com/tags/sublime/"}]},{"title":"mysql把字段的值用逗号连接成字符串","slug":"mysql把字段的值用逗号连接成字符串","date":"2019-03-01T07:14:47.000Z","updated":"2021-09-03T05:56:57.933Z","comments":true,"path":"mysql把字段的值用逗号连接成字符串/","link":"","permalink":"http://www.daichongweb.com/mysql把字段的值用逗号连接成字符串/","excerpt":"两张多对多关系的表进行数据关联查询，有两种常见的写法(我只知道两种,嘿嘿)：(1) 从主表中查出来所关联的字段，例如order_id，然后循环数组将order_id用逗号隔开；副表进行in查询（当然这种写法比较low,新手使用的比较多） (2) 使用leftJoin关联，左边为主表以上仅举例 有些情况下只能使用先查再in的写法，那么怎么简化它呢(就不想先查再循环连接)？ 那么一个mysql的函数就能使用上了，他就是GROUP_CONCAT().这个函数就是把某个字段的值用字符串连接成A,B,C这样的格式","text":"两张多对多关系的表进行数据关联查询，有两种常见的写法(我只知道两种,嘿嘿)：(1) 从主表中查出来所关联的字段，例如order_id，然后循环数组将order_id用逗号隔开；副表进行in查询（当然这种写法比较low,新手使用的比较多） (2) 使用leftJoin关联，左边为主表以上仅举例 有些情况下只能使用先查再in的写法，那么怎么简化它呢(就不想先查再循环连接)？ 那么一个mysql的函数就能使用上了，他就是GROUP_CONCAT().这个函数就是把某个字段的值用字符串连接成A,B,C这样的格式用法：1GROUP_CONCAT(字段) 去重时用法1GROUP_CONCAT(DISTINCT(字段))执行查询语句之后就会得到这个字段用逗号隔开的值","categories":[{"name":"mysql","slug":"mysql","permalink":"http://www.daichongweb.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.daichongweb.com/tags/mysql/"}]},{"title":"phpExcel分析复杂表格数据(远程文件)","slug":"phpExcel分析复杂表格数据-远程文件","date":"2019-02-26T10:17:30.000Z","updated":"2021-09-03T05:56:57.944Z","comments":true,"path":"phpExcel分析复杂表格数据-远程文件/","link":"","permalink":"http://www.daichongweb.com/phpExcel分析复杂表格数据-远程文件/","excerpt":"phpExcel是一个专门操作数据表格的类，他可以导入、导出excel表格中的数据，简单、漂亮，非常适合导入、导出、分析数据来使用。 以下代码主要为了实现从阿里OSS上获取数据表格，并分析表格数据导入数据库，唯一不同的是这个表格是不规则，分析数据的话相对来数复杂了一些，废话不多少，下面直接介绍如何处理这种复杂的表格：","text":"phpExcel是一个专门操作数据表格的类，他可以导入、导出excel表格中的数据，简单、漂亮，非常适合导入、导出、分析数据来使用。 以下代码主要为了实现从阿里OSS上获取数据表格，并分析表格数据导入数据库，唯一不同的是这个表格是不规则，分析数据的话相对来数复杂了一些，废话不多少，下面直接介绍如何处理这种复杂的表格：第一步：分析表格 经过处理，把这个底色为白色的表格处理成正常的形式经过处理可以发现，这个表格的数据是有规律的。坐标B6是账号，C6是房号，D6是房类，一次类推，每行不同的数据都是由不同字母和数字的组合。 特殊的一点就是房价在行数据的下一行，通过观察可以发现，每行的真实数据的列坐标是偶数，相对应的房价都是在奇数上，这样一分析就可以找到方法分析数据了。 第二步：实现代码 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpinclude_once('../excel/Classes/PHPExcel/IOFactory.php');//静态file_put_contents('abc.xls',file_get_contents('https://www.baidu.com/20190226/caf55125b3f510b9242235bfa7f06212.xls'));$filePath = 'abc.xls';$fileType = PHPExcel_IOFactory::identify($filePath);//检测文件类型$fileRead = PHPExcel_IOFactory::createReader($fileType);//读取文件$excelObj = $fileRead-&gt;load($filePath);$sheet = $excelObj-&gt;getActiveSheet();$highestRow = $sheet-&gt;getHighestRow();//行数$highestColumn = $sheet-&gt;getHighestColumn();//列数$dataSet = array();//数据//这里是从第6行开始，因为上5行都是空的，直接过滤for($row = 6;$row&lt;=$highestRow-4;$row++)&#123; $dataSet[$row] = array(); //列从B开始A也是空的 for($column=\"B\";$column&lt;=$highestColumn;$column++)&#123; //如果列坐标是F(房价) and 是奇数行，说明已经到房价那一行了 if($column=='F' &amp;&amp; $row%2==1)&#123; //列坐标是F 行坐标7 7-1 就是上一行,这里的意思就是上一行的F里的值等于下一行的F的值 $dataSet[$row-1][$column] = $sheet-&gt;getCell($column.$row)-&gt;getValue(); &#125;else&#123; //如果列坐标是L和N说明是时间 if($column =='L' || $column == 'N')&#123; $time = $sheet-&gt;getCell($column.$row)-&gt;getValue(); //转化时间 $dataSet[$row][$column] = date('Y-m-d H:i:s',PHPExcel_Shared_Date::ExcelToPHP($time)); &#125;else&#123; $dataSet[$row][$column] = $sheet-&gt;getCell($column.$row)-&gt;getValue(); &#125; &#125; &#125; //删除已经合并过的奇数行 if($row%2==1)&#123; unset($dataSet[$row]); &#125;else&#123; //删除空数组 $dataSet[$row] = array_filter($dataSet[$row]); &#125;&#125;echo \"&lt;pre&gt;\";print_r($dataSet); 第三步：查看结果 打印数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Array( [6] =&gt; Array ( [B] =&gt; 233756 [C] =&gt; 1AC65 [D] =&gt; DDYG [G] =&gt; 戴 [L] =&gt; 2019-02-04 12:42:00 [N] =&gt; 2019-03-06 12:00:00 [F] =&gt; 400 ) [8] =&gt; Array ( [B] =&gt; 233758 [C] =&gt; 1BC65 [D] =&gt; DDYG [G] =&gt; 戴 [H] =&gt; 48+456+844654654 [L] =&gt; 2019-02-04 12:44:00 [N] =&gt; 2019-03-06 12:00:00 [F] =&gt; 400 ) [10] =&gt; Array ( [B] =&gt; 241572 [C] =&gt; E55b [D] =&gt; DDYG [G] =&gt; 戴 [L] =&gt; 2019-02-16 09:40:00 [N] =&gt; 2019-03-30 12:00:00 [F] =&gt; 0 ) [12] =&gt; Array ( [B] =&gt; 246484 [C] =&gt; 2AC52 [D] =&gt; YGTYF [G] =&gt; 戴 [H] =&gt; 476+5456456156415641 [I] =&gt; 博客 [L] =&gt; 2019-02-25 17:23:00 [N] =&gt; 2019-02-27 12:00:00 [F] =&gt; 362 ) [14] =&gt; Array ( [B] =&gt; 246485 [C] =&gt; 2BC52 [D] =&gt; YGTYF [G] =&gt; 戴 [H] =&gt; 415645156 [I] =&gt; 博客 [L] =&gt; 2019-02-25 17:24:00 [N] =&gt; 2019-02-27 12:00:00 [F] =&gt; 362 ) [16] =&gt; Array ( [B] =&gt; 246486 [C] =&gt; D86a [D] =&gt; DDYG [G] =&gt; 戴 [H] =&gt; 156+1112 [L] =&gt; 2019-02-25 17:25:00 [N] =&gt; 2019-02-28 12:00:00 [P] =&gt; 业主自主 [F] =&gt; 0 )) 很完美，如有其它需要可根据代码调整。","categories":[{"name":"php扩展类","slug":"php扩展类","permalink":"http://www.daichongweb.com/categories/php扩展类/"}],"tags":[{"name":"phpExcel","slug":"phpExcel","permalink":"http://www.daichongweb.com/tags/phpExcel/"}]},{"title":"laravel小程序模板消息发送","slug":"larveral小程序模板消息发送","date":"2019-02-20T04:59:39.000Z","updated":"2021-09-03T05:56:57.930Z","comments":true,"path":"larveral小程序模板消息发送/","link":"","permalink":"http://www.daichongweb.com/larveral小程序模板消息发送/","excerpt":"今天来一篇laravel5.5的小程序模板消息发送示例，总感觉用laravel框架写的代码逼格高了很多，奇怪！！ 1.小程序向用户发送模板消息分为两步： 第一步：用户在小程序上进行表单操作(例如提交表单),此时前端要获取到form_id传递给后端 第二步：后端接收到from_id，再查询用户的openid，按照微信文档的数据格式进行发送2.发送之前有一下几个前提: 第一:微信小程序以开通了消息服务 第二:微信小程序以配置了模板消息 第三:发送的数据内容必须和微信小程序配置的模板消息一致 第四:获取到正确的用户openid 第五:获取到未过期的微信access_token","text":"今天来一篇laravel5.5的小程序模板消息发送示例，总感觉用laravel框架写的代码逼格高了很多，奇怪！！ 1.小程序向用户发送模板消息分为两步： 第一步：用户在小程序上进行表单操作(例如提交表单),此时前端要获取到form_id传递给后端 第二步：后端接收到from_id，再查询用户的openid，按照微信文档的数据格式进行发送2.发送之前有一下几个前提: 第一:微信小程序以开通了消息服务 第二:微信小程序以配置了模板消息 第三:发送的数据内容必须和微信小程序配置的模板消息一致 第四:获取到正确的用户openid 第五:获取到未过期的微信access_token首先是发送示例: php代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?phpclass WxHelper&#123; /** * seedTempMessage 发送模板消息 * @author DaiChong * @DateTime 2019-01-04 * @param array $seedData 需要发送的数据 格式为(key=&gt;value) * @param string $tempKey tempkey * @return json **/ public static function seedTempMessage($seedData,$tempKey) &#123; if( empty($seedData) )&#123; self::seedError('请传输数据(格式为Array)！'); return; &#125; //发送模板消息地址 $postUrl = config(\"company.seedTempMeg\"); if( $postUrl == false )&#123; self::seedError('未定义微信模板消息地址(seedTempMeg)！'); return; &#125; if($tempKey)&#123; //查询消息模板内容 $temp = \\App\\Models\\WechatMessageModel::where('temp_key',$tempKey)-&gt;first()-&gt;toArray(); if( empty($temp) )&#123; self::seedError('未添加此模板!'); return; &#125; $seedData['template_id'] = $temp['temp_id']; $temp_context = $temp['context']; $temp_json = vsprintf($temp_context,$seedData);//替换数据 $temp_array = json_decode($temp_json,true); //获取AccessToken $accessToken = self::getAccessToken(); $postUrl = str_replace('ACCESS_TOKEN', $accessToken, $postUrl); $curl = new \\JSocket(); $curl-&gt;setUrl($postUrl); $curl-&gt;setRetFormat(\\JSocket::retFormatText); foreach ($temp_array as $key =&gt; $value) &#123; $curl-&gt;setParam($key,$value); &#125; $curl-&gt;setTimeout(30); $curl-&gt;setHeader(\"Content-Type:application/json\"); $curl-&gt;setRequestType(\\JSocket::retFormatJson); $curl-&gt;setMethod(\\JSocket::methodPost); $curl-&gt;exe(); $result = $curl-&gt;getRet(); self::seedError($result); return $result; &#125;else&#123; self::seedError('未传入模板Key(tempKey)!'); return; &#125; &#125; //获取微信AccessToken 我这里已经做了access_token处理，具体细节按照微信文档进行操作或评论 public static function getAccessToken()&#123; $access_token = \\App\\Data\\WxAccessTokenData::info(); if ($access_token)&#123; return $access_token; &#125; $getAccessTokenUrl = config(\"company.getAccessToken\"); $getAccessTokenUrl = str_replace([\"APPID\",\"APPSECRET\"],[config(\"company.appid\"),config(\"company.appsecret\")],$getAccessTokenUrl); $curl = new \\JSocket(); $curl-&gt;setUrl($getAccessTokenUrl); $curl-&gt;setRetFormat(\\JSocket::retFormatJson); $curl-&gt;setTimeout(30); $curl-&gt;setMethod(\\JSocket::methodGet); $curl-&gt;exe(); $r = $curl-&gt;getRet(); return \\App\\Data\\WxAccessTokenData::set($r[\"access_token\"],$r[\"expires_in\"]); &#125; //发送失败 public static function seedError($msg)&#123; \\Log::info($msg); return \\ResponseHelper::success([ 'code' =&gt; 1, 'message' =&gt; $msg ]); &#125;&#125; 数据配置: 配置1234567891011121314151617181920212223&#123; \"touser\":\"%s\", \"template_id\":\"%s\", \"page\":\"%s\", \"form_id\":\"%s\", \"data\":&#123; \"keyword1\":&#123; \"value\":\"%s\" &#125;, \"keyword2\":&#123; \"value\":\"%s\" &#125;, \"keyword3\":&#123; \"value\":\"%s\" &#125;, \"keyword4\":&#123; \"value\":\"%s\" &#125;, \"keyword5\":&#123; \"value\":\"%s\" &#125; &#125;&#125; 这里配置也要和微信模板消息的配置一致，例如模板消息的配置内容最多到keyword8,那么这里就要在复制3个,”keyword5”:{“value”:”%s”}出来添加到后面，可以看到数据的内容都是用%s表示的，就是为了使用vsprintf替换数据。发送配置: 发送配置12345678910111213141516171819202122//发送模板消息 public function postSeedTemp() &#123; $request = \\Request::all(); if( $request['openid'] == false || $request['form_id'] == false)&#123; return \\ResponseHelper::error(\"缺少参数!\",NULL,NULL,500); &#125; $array = array( 'touser' =&gt; $request['openid'], 'template_id' =&gt; '', 'page' =&gt; 'pages/home/home', 'form_id' =&gt; $request['form_id'], 'keyword1' =&gt; '卖家正在积极准备商品', 'keyword2' =&gt; '顺丰快递', 'keyword3' =&gt; '4324242342', 'keyword4' =&gt; 'S123456789', 'keyword5' =&gt; '你的物流状态已更新' ); return \\ResponseHelper::success([ 'result' =&gt; \\WxHelper::seedTempMessage($array,'logisticsMsg') ]); &#125;可以看出这里的配置和数据配置是一一对应的。curl模拟提交示例: curl类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220&lt;?phpclass JSocket &#123; const methodGet=\"GET\"; //发起GET请求 const methodPost=\"POST\"; //发起POST请求 const methodDelete=\"DELETE\"; //发起DELETE请求 const methodPut=\"PUT\"; //发起PUT请求 const retFormatJson=\"JSON\"; //返回json格式 const retFormatXml=\"XML\"; //返回XML格式 const retFormatText=\"Text\"; //返回XML格式 private $ch; //链接对象 private $url; //请求地址 private $requestType; //请求方式 private $param=[]; //请求参数 private $timeout=10; //超时时间 private $header=[]; //请求头信息 private $method=JSocket::methodGet; //请求方式 private $file; //文件 private $ssl; //证书文件 private $ret; //返回结果 private $retFormat=JSocket::retFormatJson; //返回格式 public function __construct() &#123; $this-&gt;ch = curl_init(); &#125; public function setRetFormat($retFormat)&#123; $this-&gt;retFormat=$retFormat; return $this; &#125; public function setRequestType($requestType) &#123; $this-&gt;requestType=$requestType; &#125; /** * 设置请求地址 */ public function setUrl($url)&#123; $this-&gt;url=$url; return $this; &#125; /** * 设置请求参数 * @param type $key * @param type $value * @return \\JSocket */ public function setParam($key,$value)&#123; $this-&gt;param[$key]=$value; return $this; &#125; /** * 获取请求参数 * @param type $key * @param type $value * @return \\JSocket */ public function getParam()&#123; return $this-&gt;param; &#125; /** * 设置请求超时时间 * @param type $timeout * @return \\JSocket */ public function setTimeout($timeout)&#123; $this-&gt;timeout=$timeout; return $this; &#125; /** * 设置请求头 * @param type $header * @return \\JSocket */ public function setHeader($header)&#123; $this-&gt;header[]=$header; return $this; &#125; /** * 设置请求方式 * @param type $method * @return \\JSocket */ public function setMethod($method)&#123; $this-&gt;method=$method; return $this; &#125; /** * 设置发送文件 * @param type $key * @param type $value * @return \\JSocket */ public function setFile($key,$file)&#123; $this-&gt;file[$key]=curl_file_create($file); return $this; &#125; /** * 设置整数文件 * @param type $ssl * @return \\JSocket */ public function ssl($ssl)&#123; $this-&gt;ssl=$ssl; return $this; &#125; /** * 请求接口 * @return \\JSocket */ public function exe()&#123; curl_setopt($this-&gt;ch, CURLOPT_TIMEOUT, $this-&gt;timeout); curl_setopt($this-&gt;ch, CURLOPT_RETURNTRANSFER, true); if($this-&gt;header)&#123; curl_setopt($this-&gt;ch,CURLOPT_HTTPHEADER, $this-&gt;header); curl_setopt($this-&gt;ch,CURLOPT_HEADER,FALSE); &#125; switch ($this-&gt;method) &#123; case self::methodPost: curl_setopt($this-&gt;ch, CURLOPT_POST, TRUE); if($this-&gt;file)&#123; curl_setopt($this-&gt;ch, CURLOPT_POSTFIELDS, $this-&gt;file); &#125; if($this-&gt;param)&#123; if ($this-&gt;requestType==self::retFormatJson)&#123; curl_setopt($this-&gt;ch, CURLOPT_POSTFIELDS, json_encode($this-&gt;param)); &#125;else if ($this-&gt;requestType==self::retFormatXml)&#123; curl_setopt($this-&gt;ch, CURLOPT_POSTFIELDS, \\DataBaseHelper::arrayToXml($this-&gt;param)); &#125;else&#123; curl_setopt($this-&gt;ch, CURLOPT_POSTFIELDS, http_build_query($this-&gt;param)); &#125; &#125; break; case self::methodDelete: curl_setopt($this-&gt;ch, CURLOPT_CUSTOMREQUEST, 'DELETE'); case self::methodGet: if($this-&gt;param)&#123; $this-&gt;url = $this-&gt;url . (strpos($this-&gt;url, '?') ? '&amp;' : '?') . http_build_query($this-&gt;param); &#125; &#125; if($this-&gt;ssl)&#123; curl_setopt($this-&gt;ch,CURLOPT_SSLCERTTYPE,'PEM'); curl_setopt($this-&gt;ch,CURLOPT_SSLCERT, $this-&gt;ssl['cert']); curl_setopt($this-&gt;ch,CURLOPT_SSLKEYTYPE,'PEM'); curl_setopt($this-&gt;ch,CURLOPT_SSLKEY, $this-&gt;ssl['key']); curl_setopt($this-&gt;ch,CURLOPT_SSL_VERIFYPEER,TRUE); curl_setopt($this-&gt;ch,CURLOPT_SSL_VERIFYHOST,2);//严格校验 curl_setopt($this-&gt;ch,CURLOPT_HEADER, FALSE); if (isset($this-&gt;ssl['ca']))&#123; curl_setopt($this-&gt;ch,CURLOPT_CAINFO, $this-&gt;ssl['ca']); &#125; &#125;else&#123; curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYHOST, false); &#125; curl_setopt($this-&gt;ch, CURLOPT_URL, $this-&gt;url); $starttime=$this-&gt;microtimeFloat(); $this-&gt;ret = curl_exec($this-&gt;ch); $endtime = $this-&gt;microtimeFloat(); $errorNum=curl_errno($this-&gt;ch); $errorMsg=curl_error($this-&gt;ch); $runtime = number_format(($endtime-$starttime), 4).'s'; if($errorNum)&#123; Log::error($this-&gt;url, [\"param\"=&gt;$this-&gt;param,\"result\"=&gt;$errorNum,\"runtime\"=&gt;$runtime,\"response\"=&gt;$this-&gt;ret]); Log::error(\"curl请求错误信息：\".$errorMsg); return NULL; &#125; $this-&gt;http_code = curl_getinfo($this-&gt;ch,CURLINFO_HTTP_CODE); curl_close ($this-&gt;ch); Log::info($this-&gt;url, [\"param\"=&gt;$this-&gt;param,\"status\"=&gt;$this-&gt;http_code,\"runtime\"=&gt;$runtime,\"response\"=&gt;$this-&gt;ret]); return $this; &#125; /** * 获取结果 */ public function getRet()&#123; switch ($this-&gt;retFormat)&#123; case JSocket::retFormatJson: return json_decode($this-&gt;ret,TRUE); break; case JSocket::retFormatXml: return \\DataBaseHelper::xmlToArray($this-&gt;ret); break; &#125; return $this-&gt;ret; &#125; public function getHttpCode()&#123; return $this-&gt;http_code; &#125; /** * 精确时间 * @return type */ public function microtimeFloat()&#123; list($usec, $sec) = explode(\" \", microtime()); return ((float)$usec + (float)$sec); &#125;&#125;","categories":[{"name":"php框架","slug":"php框架","permalink":"http://www.daichongweb.com/categories/php框架/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://www.daichongweb.com/tags/laravel/"}]},{"title":"tp5模型事件‘before_insert’用法","slug":"tp5模型事件‘beforeInsert’用法","date":"2019-02-19T02:19:58.000Z","updated":"2021-09-03T05:56:57.966Z","comments":true,"path":"tp5模型事件‘beforeInsert’用法/","link":"","permalink":"http://www.daichongweb.com/tp5模型事件‘beforeInsert’用法/","excerpt":"tp5的模型事件只有在调用模型方法的时候生效，使用查询构造器是无效的。 引言TP5官网 也就是说，不实例化模型进行操作before_insert这个方法是不执行的。 模型的意义就是为了简化控制器操作，简化逻辑处理，提升代码的整洁度和可读性。这样一来模型事件起到了至关重要的作用。","text":"tp5的模型事件只有在调用模型方法的时候生效，使用查询构造器是无效的。 引言TP5官网 也就是说，不实例化模型进行操作before_insert这个方法是不执行的。 模型的意义就是为了简化控制器操作，简化逻辑处理，提升代码的整洁度和可读性。这样一来模型事件起到了至关重要的作用。这篇文章就介绍一下模型事件‘before_insert’事件对于下单逻辑的帮助。模型ShopOrder1234567891011121314151617&lt;?phpnamespace app\\common\\model;use think\\Model;use daichongweb\\helper;class ShopOrderM extends Model&#123; protected $table = 'shop_text'; protected static function init() &#123; self::beforeInsert(function($ShopOrderM)&#123; //创建订单号 $ShopOrderM['orderno'] = helper::buildOrderno('T', 'shop_text'); $ShopOrderM['name'] = $ShopOrderM['name'].'1';//处理前端传过来的数据进行操作 return $ShopOrderM; &#125;,true); &#125;&#125; 控制器1234567891011121314151617181920212223242526272829&lt;?phpnamespace app\\api\\controller;use daichongweb\\helper;use think\\response\\Json;use think\\Db;use think\\facade\\Request;use think\\facade\\Cache;use app\\api\\controller\\ShopMain;/** * 商城下单接口 */class ShopOrder&#123; //下单测试 public function orderText() &#123; $info = input(); //验证器 $validate = new \\app\\common\\validate\\ShopOrderV(); if(!$validate-&gt;check($info)) &#123; return new Json([ 'code' =&gt; 1, 'message' =&gt; $validate-&gt;getError(), ]); &#125; $shopOrder = new \\app\\common\\model\\ShopOrderM(); $shopOrder-&gt;save($info); &#125;&#125; 从控制器的代码可以看出，控制器的逻辑处理只有接收数据、验证、执行插入。生成订单、处理数据全部放在模型的新增前处理。$ShopOrderM[‘name’] = $ShopOrderM[‘name’].’1’;这里就是自动向数据表的name插入数据。","categories":[{"name":"php框架","slug":"php框架","permalink":"http://www.daichongweb.com/categories/php框架/"}],"tags":[{"name":"tp5","slug":"tp5","permalink":"http://www.daichongweb.com/tags/tp5/"}]},{"title":"tp5类的属性不存在","slug":"tp5类的属性不存在","date":"2019-02-16T06:13:53.000Z","updated":"2021-09-03T05:56:57.966Z","comments":true,"path":"tp5类的属性不存在/","link":"","permalink":"http://www.daichongweb.com/tp5类的属性不存在/","excerpt":"tp5模型新增关联报错类的属性不存在,即使数据表中存在需要的字段，但是依然报错app\\common\\model\\Slide-&gt;is_slide类似的问题，其实是因为在使用关联模型新增的时候主表新增操作未使用模型新增。","text":"tp5模型新增关联报错类的属性不存在,即使数据表中存在需要的字段，但是依然报错app\\common\\model\\Slide-&gt;is_slide类似的问题，其实是因为在使用关联模型新增的时候主表新增操作未使用模型新增。错误写法12345//直接新增未使用模型$result = Db::name('table')-&gt;allowField(true)-&gt;save($info);//然后使用模型新增$model = new \\app\\common\\model\\ShopCommentM();$model-&gt;comment_image()-&gt;saveAll($imageData); 正确写法1234//先使用模型新增主表，再新增关联表$model = new \\app\\common\\model\\ShopCommentM();$model-&gt;allowField(true)-&gt;save($info);$model-&gt;comment_image()-&gt;saveAll($imageData); 模型文件1234567891011121314151617181920212223//主表模型&lt;?phpnamespace app\\common\\model;use think\\Model;class ShopCommentM extends Model&#123; protected $table = 'shop_comment'; public function comment_image() &#123; return $this-&gt;hasMany('ShopCommentImageM','comment_id'); &#125;&#125;//关联表模型&lt;?phpnamespace app\\common\\model;use think\\Model;class ShopCommentImageM extends Model&#123; protected $table = 'shop_comment_image';&#125;","categories":[],"tags":[{"name":"tp5","slug":"tp5","permalink":"http://www.daichongweb.com/tags/tp5/"}]},{"title":"php关于trait的使用","slug":"php关于trait的使用","date":"2019-01-25T09:28:45.000Z","updated":"2021-09-03T05:56:57.954Z","comments":true,"path":"php关于trait的使用/","link":"","permalink":"http://www.daichongweb.com/php关于trait的使用/","excerpt":"关于trait之前可以说是完全没有了解过，看了官方文档之后才得知是php5.4的新特性,用来解决在不同结构(模块)下代码复用的问题.具体可以查看php手册手册的介绍相对来说还是比较清晰的，那这篇文章就是为了献给那些不喜欢看文档，喜欢直接上手使用的童鞋. 首先介绍一下我的项目结构 我在Common模块下新建了一个文件traits 命名空间为 common/traits。 现在有多个模块需要使用相同的代码，那么就在traits下新建一个控制器,写入公用的代码","text":"关于trait之前可以说是完全没有了解过，看了官方文档之后才得知是php5.4的新特性,用来解决在不同结构(模块)下代码复用的问题.具体可以查看php手册手册的介绍相对来说还是比较清晰的，那这篇文章就是为了献给那些不喜欢看文档，喜欢直接上手使用的童鞋. 首先介绍一下我的项目结构 我在Common模块下新建了一个文件traits 命名空间为 common/traits。 现在有多个模块需要使用相同的代码，那么就在traits下新建一个控制器,写入公用的代码common/traits/ShopGoods.php123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace \\common\\traits;trait ShopGoods&#123; use \\app\\common\\traits\\ShopCommon;//这里是引用了其他的公共方法 //商品数据 private function goodsList($company_id,$hotel_id = NULL) &#123; $post = input(); $post['company_id'] = $company_id; $post['hotel_id'] = $hotel_id; $post['my'] = isset($post['my'])??false; $goods = new ShopGoodsM(); $model = $goods-&gt;alias('goods') -&gt;leftJoin('shop_goods_category gcat','goods.id=gcat.goods_id') -&gt;leftJoin('shop_category cat','gcat.category_id=cat.category_id') -&gt;where('cat.deletetime',NULL); if($post['my'])&#123; $model-&gt;withSearch(['company_id','hotel_id'],$post); &#125;else&#123; $model-&gt;withSearch(['company_id'],$post); &#125; $model-&gt;group('goods.id'); $list = $model-&gt;field(\"GROUP_CONCAT(DISTINCT(cat.name)) as category_name,goods.*\") -&gt;select(); //查询sku属性 foreach ($list as $key =&gt; $value) &#123; $list[$key]['sku'] = $goods-&gt;skus()-&gt;where('goods_id',$value['id'])-&gt;field('sku,price,stock,score')-&gt;select(); &#125; $total = $model-&gt;count(); return new Json([ 'code' =&gt; 0, 'message' =&gt; 'success', 'data' =&gt; $list, 'total' =&gt; $total ]); &#125;&#125;?&gt;那上边这块代码现在有Company和Hotel两个模块要使用:company/index.php123456789101112&lt;?phpnamespace company\\controller;class ShopGoods&#123; use \\common\\traits\\ShopGoods;//引入公共的traits文件 //商品数据 public function getGoods() &#123; return $this-&gt;goodsList(helper::getCompanyIdInCompany()); &#125;&#125;?&gt;这样的话Company和Hotel模块下只有写这两行代码就够了。 看到这里其实很多人会有疑问，说:这不和普通的代码公用是一个类型吗？不不不！他们不一样，例如很多模块下的参数是无法公用的,company下的company_id在hotel模块下是无法调用的,但引入trait方法之后，你就可以在不同的模块下做参数处理,trait方法既可以通过默认参数的形式传递也可以接收post、get等方法的传递。安全方面：trait方法不可直接通过接口访问、相比用公用的common方法做访问处理省事了很多！","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"js一次提交却发起多次请求","slug":"js一次提交却发起多次请求","date":"2019-01-21T02:25:46.000Z","updated":"2021-09-03T05:56:57.929Z","comments":true,"path":"js一次提交却发起多次请求/","link":"","permalink":"http://www.daichongweb.com/js一次提交却发起多次请求/","excerpt":"最近做前端的工作比较多,经常会遇到一些自己不太明白的问题，非常的懵逼。比如做一个简单的ajax异步提交会出现两次请求的问题，也是最近遇见比较奇怪的问题。 经过排查之后发现两次出现两次请求的原因可能是：1.引入了两个同样的js,比如引入了两个同样的jquery插件","text":"最近做前端的工作比较多,经常会遇到一些自己不太明白的问题，非常的懵逼。比如做一个简单的ajax异步提交会出现两次请求的问题，也是最近遇见比较奇怪的问题。 经过排查之后发现两次出现两次请求的原因可能是：1.引入了两个同样的js,比如引入了两个同样的jquery插件 2.页面存在form表单，点击提交按钮之后又执行了form.submit(),这个form本身就会提交一次。 3.跨域请求，这个问题就比较深入一点了，js跨域的时候本身会发送两次请求，第一次是预查请求(option)，是为了查询是否支持跨域，第二次才是真正的数据请求。解决这个问题，首先后端要有允许跨域请求的处理，前端的header要加入application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种，就可以解决了。 后端跨域处理123header('Access-Control-Allow-Origin: *');header(\"Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\");header('Access-Control-Allow-Methods: GET, POST, PUT');","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.daichongweb.com/tags/js/"}]},{"title":"小程序服务商支付","slug":"小程序服务商支付","date":"2018-11-13T07:59:14.000Z","updated":"2021-09-03T05:56:57.976Z","comments":true,"path":"小程序服务商支付/","link":"","permalink":"http://www.daichongweb.com/小程序服务商支付/","excerpt":"建议按照接口文档进行开发,不要直接使用sdk下面贴上代码为大家一一介绍文档和真实情况的差距:","text":"建议按照接口文档进行开发,不要直接使用sdk下面贴上代码为大家一一介绍文档和真实情况的差距:123456789101112131415161718192021222324252627282930313233343536373839require './common/payConfig.php';$key = $payConfig['key'];$orderData = array( \"appid\" =&gt; $payConfig['appid'], 'mch_id' =&gt; $payConfig['mchid'], 'sub_appid' =&gt; $payConfig['sub_appid'], 'sub_mch_id' =&gt; $mchid, 'body' =&gt; $body, 'attach' =&gt; $attach, 'out_trade_no' =&gt; $order_id, 'total_fee' =&gt; $total_price, 'spbill_create_ip' =&gt; $_SERVER['REMOTE_ADDR'], 'notify_url' =&gt; 'daichongweb.com', 'trade_type' =&gt; 'JSAPI', // 'openid' =&gt; $UnionID, 这个是不需要的 'goods_tag' =&gt; 'daichong', 'nonce_str' =&gt; $this-&gt;getNonceStr(), 'sub_openid' =&gt; $mini_openid);ksort($orderData);reset($orderData);$buff = \"\";foreach ($orderData as $k =&gt; $v)&#123; if($k != \"sign\" &amp;&amp; $v != \"\" &amp;&amp; !is_array($v))&#123; $buff .= ($k . \"=\" . $v . \"&amp;\"); &#125;&#125;$buff = trim($buff, \"&amp;\");$buff = $buff.'&amp;key='.$key;$signA = strtoupper(MD5($buff));$orderData['sign'] = $signA;$xml = $this-&gt;arrayToXml($orderData);$url = \"https://api.mch.weixin.qq.com/pay/unifiedorder\"; $result = $this-&gt;https_post($url,$xml);$payArray = (array)simplexml_load_string($result, 'SimpleXMLElement', LIBXML_NOCDATA);在代码上的差距其实只有一个openid,但是他还是会报错appid和sub_mch_id不匹配,解决这个问题的前提小程序和公众号的主体必须一致,也就是小程序和微信公众号必须在同一个服务商上绑定。绑定方式是在服务商户里找到’服务商功能‘-&gt;’特约商户管理‘找到对应商户点击配置第一步： 第二步： 添加好之后就可以测试支付了，把支付参数返回给前端，啊就完事了!","categories":[],"tags":[{"name":"小程序支付","slug":"小程序支付","permalink":"http://www.daichongweb.com/tags/小程序支付/"}]},{"title":"谷歌浏览器Flash没有添加按键","slug":"谷歌浏览器Flash没有添加按键","date":"2018-09-14T08:22:12.000Z","updated":"2021-09-03T05:56:57.988Z","comments":true,"path":"谷歌浏览器Flash没有添加按键/","link":"","permalink":"http://www.daichongweb.com/谷歌浏览器Flash没有添加按键/","excerpt":"关于谷歌浏览器不能使用Flash的问题大家肯定遇到过，只要在设置-》高级-》内容管理-》Flash里添加网站就可以了今天我更新了一下浏览器，升级到了最新的版本，发现Flash又使用不了。按照以往的流程去添加居然发现没有居然没有添加按钮","text":"关于谷歌浏览器不能使用Flash的问题大家肯定遇到过，只要在设置-》高级-》内容管理-》Flash里添加网站就可以了今天我更新了一下浏览器，升级到了最新的版本，发现Flash又使用不了。按照以往的流程去添加居然发现没有居然没有添加按钮然后就是长达1个多小时的百度，试了无数的方法都没有解决，最后静下来思考之后才有了头绪。那么最终的解决方法是什么呢？首先：在浏览器输入1chrome://flags/#run-all-flash-in-allow-mode搜索：搜索1Enable Ephemeral Flash Permissions修改状态为Disabled然后下面会弹出一个框，点击一下按钮就可以了！","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://www.daichongweb.com/tags/浏览器/"}]},{"title":"php根据二位数据中的某个键值排序","slug":"php根据二位数据中的某个键值排序","date":"2018-09-11T08:57:41.000Z","updated":"2021-09-03T05:56:57.960Z","comments":true,"path":"php根据二位数据中的某个键值排序/","link":"","permalink":"http://www.daichongweb.com/php根据二位数据中的某个键值排序/","excerpt":"下面先为大家介绍两个php函数：array_column():返回输入数组中某个单一列的值。小例子： array_column的用法123456789101112131415161718$a = array( array( 'id' =&gt; 5698, 'first_name' =&gt; 'daichong', 'last_name' =&gt; 'css', ), array( 'id' =&gt; 4767, 'first_name' =&gt; 'dc', 'last_name' =&gt; 'js', ), array( 'id' =&gt; 3809, 'first_name' =&gt; 'DC', 'last_name' =&gt; 'web', ));$lastNames = array_column($a,'first_name')","text":"下面先为大家介绍两个php函数：array_column():返回输入数组中某个单一列的值。小例子： array_column的用法123456789101112131415161718$a = array( array( 'id' =&gt; 5698, 'first_name' =&gt; 'daichong', 'last_name' =&gt; 'css', ), array( 'id' =&gt; 4767, 'first_name' =&gt; 'dc', 'last_name' =&gt; 'js', ), array( 'id' =&gt; 3809, 'first_name' =&gt; 'DC', 'last_name' =&gt; 'web', ));$lastNames = array_column($a,'first_name')打印结果123456Array( [0] =&gt; daichong [1] =&gt; dc [2] =&gt; DC) array_multisort():返回指定排序后的数组。函数返回排序数组。您可以输入一个或多个数组。函数先对第一个数组进行排序，接着是其他数组，如果两个或多个值相同，它将对下一个数组进行排序。注释：字符串键名将被保留，但是数字键名将被重新索引，从 0 开始，并以 1 递增。注释：您可以在每个数组后设置排序顺序和排序类型参数。如果没有设置，每个数组参数会使用默认值。实践： 代码123456789101112131415161718$arr=array( 0=&gt;array( 'run_date'=&gt;3, 'count'=&gt;'5' ), 1=&gt;array( 'run_date'=&gt;2, 'count'=&gt;'10' ), 2=&gt;array( 'run_date'=&gt;1, 'count'=&gt;'10' ) );$date = array_column($arr, 'run_date');array_multisort($date,SORT_ASC,$arr);echo \"&lt;pre&gt;\";print_r($arr); 结果： 打印结果123456789101112131415161718192021Array( [0] =&gt; Array ( [run_date] =&gt; 1 [count] =&gt; 10 ) [1] =&gt; Array ( [run_date] =&gt; 2 [count] =&gt; 10 ) [2] =&gt; Array ( [run_date] =&gt; 3 [count] =&gt; 5 )) 是不是根据指定的键值进行排序了呢？","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"web端存储数据(cookie,storage)选择和使用","slug":"web端存储数据-cookie-storage-选择和使用","date":"2018-08-17T07:49:37.000Z","updated":"2021-09-03T05:56:57.975Z","comments":true,"path":"web端存储数据-cookie-storage-选择和使用/","link":"","permalink":"http://www.daichongweb.com/web端存储数据-cookie-storage-选择和使用/","excerpt":"关于前端存储的方法用很多，最为常见的是cookie和locationStorage。 其中cookie的限制比较大，比如必须需要cookie.js、浏览器对cookie的数量限制(之前的浏览器每个域名限制cookie之恶能存储50个)，数据长度的限制(大部分浏览器是4085字节左右,但实际更小)。 locationstorage能存储4-5M大小的数据，有效期未永久。 application cache 是离线缓存，存储大小也是5M左右,他与其他两种方式的不同在与浏览器缓存是对单个文件，而applocation cache是对整个应用，当整个应用都缓存下来的时候可以达到无网络连接。 今天我要写的是locationstorage的sessionStorage，他们的用法完全相同，很简单，但是真的很实用。今天使用之后我觉得这个sessionStorage真的是太方便了。","text":"关于前端存储的方法用很多，最为常见的是cookie和locationStorage。 其中cookie的限制比较大，比如必须需要cookie.js、浏览器对cookie的数量限制(之前的浏览器每个域名限制cookie之恶能存储50个)，数据长度的限制(大部分浏览器是4085字节左右,但实际更小)。 locationstorage能存储4-5M大小的数据，有效期未永久。 application cache 是离线缓存，存储大小也是5M左右,他与其他两种方式的不同在与浏览器缓存是对单个文件，而applocation cache是对整个应用，当整个应用都缓存下来的时候可以达到无网络连接。 今天我要写的是locationstorage的sessionStorage，他们的用法完全相同，很简单，但是真的很实用。今天使用之后我觉得这个sessionStorage真的是太方便了。测试cookie存储 最终发现1837的长度存不进去。sessionStorage 的使用 sessionStorage1234//存储sessionStorage.setItem('newList',str)//获取sessionStorage.getItem('newList')","categories":[],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://www.daichongweb.com/tags/jquery/"}]},{"title":"php循环处理万条数据如何优化？","slug":"php循环处理万条数据如何优化？","date":"2018-08-10T02:31:13.000Z","updated":"2021-09-03T05:56:57.955Z","comments":true,"path":"php循环处理万条数据如何优化？/","link":"","permalink":"http://www.daichongweb.com/php循环处理万条数据如何优化？/","excerpt":"今天来写一篇如何优化在循环里的sql。相信大家都会遇到在foreach里循环操作数据库，上学的时候一听到循环查表这类的词，哇！感觉很高端，殊不知这样的操作对数据库的压力是无限大的。像一个三级的分类数据操作，很多人会选择循环查表，毕竟这样的写法是最方便、最简单的。前期数据量小的时候是没有很明显的问题，到了一定程度，你会发现页面加载速度越来越慢，数据库的压力越来越大。这个时候你必须要选择修改你的程序了！ 但是这篇文章不是来介绍如何优化循环查询的，是介绍如何来优化循环修改表数据的。","text":"今天来写一篇如何优化在循环里的sql。相信大家都会遇到在foreach里循环操作数据库，上学的时候一听到循环查表这类的词，哇！感觉很高端，殊不知这样的操作对数据库的压力是无限大的。像一个三级的分类数据操作，很多人会选择循环查表，毕竟这样的写法是最方便、最简单的。前期数据量小的时候是没有很明显的问题，到了一定程度，你会发现页面加载速度越来越慢，数据库的压力越来越大。这个时候你必须要选择修改你的程序了！ 但是这篇文章不是来介绍如何优化循环查询的，是介绍如何来优化循环修改表数据的。下面介绍一下我正在做的一些业务：数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Array( [0] =&gt; Array ( [did] =&gt; 1446175 [userid] =&gt; 449310 [danhao] =&gt; W1808100219 [isno] =&gt; 2 [green_state] =&gt; R [id] =&gt; 19 [time] =&gt; 2018-08-10 11:06:30 ) [1] =&gt; Array ( [did] =&gt; 1446174 [userid] =&gt; 456791 [danhao] =&gt; W1808100218 [isno] =&gt; 2 [green_state] =&gt; R [id] =&gt; 34 [time] =&gt; 2018-08-10 11:06:30 ) [2] =&gt; Array ( [did] =&gt; 1446172 [userid] =&gt; 113637 [danhao] =&gt; W1808100217 [isno] =&gt; 2 [green_state] =&gt; R [id] =&gt; 38 [time] =&gt; 2018-08-10 11:06:30 ) [3] =&gt; Array ( [did] =&gt; 1446171 [userid] =&gt; 10884 [danhao] =&gt; W1808100216 [isno] =&gt; 2 [green_state] =&gt; R [id] =&gt; 5 [time] =&gt; 2018-08-10 11:06:30 ) [4] =&gt; Array ( [did] =&gt; 1446169 [userid] =&gt; 79165 [danhao] =&gt; W1808100214 [isno] =&gt; 2 [green_state] =&gt; R [id] =&gt; 11 [time] =&gt; 2018-08-10 11:06:30 ))code snippet 这个功能的要求是同步订单，数据就像上边展示的一样 green_state 的值是不固定的，可能是R也可能是X,这个代表的是订单的状态。我现在要做的是拿这个订单状态去把他相应的字段值改成这个状态。 原始写法:循环修改 逻辑123foreach($order as $k=&gt;$v)&#123; Db::query(\"update order set green_state=$v['green_state'] set did=$v['did']\");&#125; 这样的写法有多少条数据就会请求数据库多少次，无疑是最消耗性能的写法。优化写法：链接sql 逻辑代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//预定sql s$Rsql = '';$RsetIds = '';//e//取消sql s$Xsql = '';$XsetIds = '';//e//I$Isql = '';$IsetIds = '';////O$Osql = '';$OsetIds = '';////N$Nsql = '';$NsetIds = '';////D$Dsql = '';$DsetIds = '';//foreach ($order_data as $k =&gt; $v) &#123; $order_data[$k]['time'] = date('Y-m-d H:i:s'); $data = json_decode($this-&gt;order_info($pms['url'],$pms['jiudian'],$pms['hotelgroupId'],$v['danhao']),true); if($data['resultCode']==0)&#123; $order_data[$k]['green_state'] = $data['guest']['sta']; &#125; //组合sql R类型 预定 if($order_data[$k]['green_state']=='R')&#123; $Rsql = \"set green_state='R'\"; $RsetIds .= $v['did'].','; &#125; //组合sql X类型 取消 if($order_data[$k]['green_state']=='X')&#123; $Xsql = \"set green_state='X'\"; $XsetIds .= $v['did'].','; &#125; //组合sql I类型 在住 if($order_data[$k]['green_state']=='I')&#123; $Isql = \"set green_state='I'\"; $IsetIds .= $v['did'].','; &#125; //组合sql O类型 退房 if($order_data[$k]['green_state']=='O')&#123; $Osql = \"set green_state='O'\"; $OsetIds .= $v['did'].','; &#125; //组合sql N类型 应到未到 if($order_data[$k]['green_state']=='N')&#123; $Nsql = \"set green_state='N'\"; $NsetIds .= $v['did'].','; &#125; //组合sql D类型 删除 if($order_data[$k]['green_state']=='D')&#123; $Dsql = \"set green_state='D'\"; $DsetIds .= $v['did'].','; &#125;&#125;$RsetIds = trim($RsetIds,',');$XsetIds = trim($XsetIds,',');$IsetIds = trim($IsetIds,',');$OsetIds = trim($OsetIds,',');$NsetIds = trim($NsetIds,',');$DsetIds = trim($DsetIds,',');$sql = \"update order $Rsql where did in($RsetIds)\";以上就是我根据需求调整的代码，通过不同订单类型组成不同的sql，最终实现6条sql完成6个类型的修改，如果是10w条数据，那么请求数据库的次数是6次，相比之前的次数降低了9千多次！达到了优化的效果，当然这个代码还有优化的空间。以上代码只是为大家提供思路，具体业务逻辑还要根据实际情况而定！","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.daichongweb.com/tags/mysql/"}]},{"title":"php做一个简单的日志功能","slug":"php做一个简单的日志功能","date":"2018-08-03T09:06:20.000Z","updated":"2021-09-03T05:56:57.953Z","comments":true,"path":"php做一个简单的日志功能/","link":"","permalink":"http://www.daichongweb.com/php做一个简单的日志功能/","excerpt":"今天一直在和别的公司对接接口，之前的对接都没有做来往日志，这样的话功能出了问题要针对性的找到问题的原因比较麻烦，逼不得已只能做个日志记录一下。而且程序还没有使用任何框架，又不想研究别人的代码，没办法只能自己简单的做一个写入日志的功能。","text":"今天一直在和别的公司对接接口，之前的对接都没有做来往日志，这样的话功能出了问题要针对性的找到问题的原因比较麻烦，逼不得已只能做个日志记录一下。而且程序还没有使用任何框架，又不想研究别人的代码，没办法只能自己简单的做一个写入日志的功能。实现逻辑: 写入文件1234567891011121314151617181920212223242526272829/** * 写入日志 * * @access public * @param must $path 写入日志的地址(./log/) * @param must $data 写入内容 * @param optional $fileName 文件名称 * @return Number 1 成功 0 失败 */ public static function write_log($path,$data,$fileName='error')&#123; $file_path = $path.date('Y-m-d'); //文件夹不存在创建文件夹 if(!file_exists($file_path))&#123; mkdir($file_path,0777,true); &#125; //文件完整路径 $file = $path.date('Y-m-d').\"/\".$fileName.\".txt\"; //打开文件 \"a+\" 读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建 $handle = fopen($file,\"a+\"); //写入文件 $str = fwrite($handle,date('Y-m-d H:i:s').':'.json_encode($data).\"\\n\"); //关闭文件 fclose($handle); if($str)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;调用方法: 调用1echo Db::write_log('./log/',array(1,2,3,4,5,6,7),'greenCloudReturnMsg');效果：","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"mysql更新sql优化","slug":"mysql更新sql优化","date":"2018-07-28T08:35:30.000Z","updated":"2021-09-03T05:56:57.934Z","comments":true,"path":"mysql更新sql优化/","link":"","permalink":"http://www.daichongweb.com/mysql更新sql优化/","excerpt":"mysql on duplicate key update 对于不是很常用的人来说是比较陌生的。那么他到底是用来干什么的呢？下面就介绍一下： 比如在我们做一个点击量的功能，程序的逻辑是这样的：在用户点击的时候我们首先要判断数据表中已经存在了这个人的数据，如果存在日志表对应的用户点击次数加1，如果不存在新增一条数据。 那么按照正常的编程需要有两条sql 先查询数据表中是否有，有了执行修改操作，没有执行添加操作。一条查询一条修改或添加。 那么有了这个on duplicate key update 之后就可以把这两个sql简化为一条，减少了数据的查询次数、避免了数据重复而且少打一些代码，可谓是一举三得！","text":"mysql on duplicate key update 对于不是很常用的人来说是比较陌生的。那么他到底是用来干什么的呢？下面就介绍一下： 比如在我们做一个点击量的功能，程序的逻辑是这样的：在用户点击的时候我们首先要判断数据表中已经存在了这个人的数据，如果存在日志表对应的用户点击次数加1，如果不存在新增一条数据。 那么按照正常的编程需要有两条sql 先查询数据表中是否有，有了执行修改操作，没有执行添加操作。一条查询一条修改或添加。 那么有了这个on duplicate key update 之后就可以把这两个sql简化为一条，减少了数据的查询次数、避免了数据重复而且少打一些代码，可谓是一举三得！sql1insert into t_my (id,click) VALUES (2,1) on DUPLICATE KEY UPDATE click=click+1;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.daichongweb.com/tags/mysql/"}]},{"title":"微信小程序开发获取unionID","slug":"微信小程序开发获取unionID","date":"2018-07-27T07:04:42.000Z","updated":"2021-09-03T05:56:57.977Z","comments":true,"path":"微信小程序开发获取unionID/","link":"","permalink":"http://www.daichongweb.com/微信小程序开发获取unionID/","excerpt":"这几天在做一个微信小程序，在微信公众平台已经完成的配置，以及接口的开发。最后却发现小程序的openid和微信公众号的不一致，再看了微信文档之后发现，小程序和微信公号的openid都是独立的。只有一个UnionID是通用的，到这里就可以通过微信的接口getuserinfo去获取了。但是有很多人是获取不到的，下面就介绍一下有什么情况是获取不到的：第一种情况：微信请求用户授权，用户未同意 第二种情况：用户没有关注过小程序绑定的公众号、也没有登录过 第三种：在微信公众平台未绑定开发者 如果这三种情况都没有，是可以获取到unionId的。","text":"这几天在做一个微信小程序，在微信公众平台已经完成的配置，以及接口的开发。最后却发现小程序的openid和微信公众号的不一致，再看了微信文档之后发现，小程序和微信公号的openid都是独立的。只有一个UnionID是通用的，到这里就可以通过微信的接口getuserinfo去获取了。但是有很多人是获取不到的，下面就介绍一下有什么情况是获取不到的：第一种情况：微信请求用户授权，用户未同意 第二种情况：用户没有关注过小程序绑定的公众号、也没有登录过 第三种：在微信公众平台未绑定开发者 如果这三种情况都没有，是可以获取到unionId的。","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://www.daichongweb.com/tags/微信小程序/"}]},{"title":"sublime配置自动上传文件","slug":"sublime配置自动上传文件","date":"2018-07-26T10:08:06.000Z","updated":"2021-09-03T05:56:57.965Z","comments":true,"path":"sublime配置自动上传文件/","link":"","permalink":"http://www.daichongweb.com/sublime配置自动上传文件/","excerpt":"最近一直在修改公司老系统上的bug,因为老系统上没有安装git以及其他的版本控制软件，所以只能用ftp上传。 这个过程是极为痛苦的，要想修改一个文件必须先下载，再修改，再上传。每次点来点去终于把我搞烦了，今天下定决心一定要搞一个自动上传。 之后就是在百度不断的找资料，在融合了多篇资料的精华后终于搭建成功！ 一次次的测试后，哈哈哈哈！！！！！！完全没问题！！！！！！！ 下面为大家奉献实现步骤：","text":"最近一直在修改公司老系统上的bug,因为老系统上没有安装git以及其他的版本控制软件，所以只能用ftp上传。 这个过程是极为痛苦的，要想修改一个文件必须先下载，再修改，再上传。每次点来点去终于把我搞烦了，今天下定决心一定要搞一个自动上传。 之后就是在百度不断的找资料，在融合了多篇资料的精华后终于搭建成功！ 一次次的测试后，哈哈哈哈！！！！！！完全没问题！！！！！！！ 下面为大家奉献实现步骤：第一步：打开sublime 安住Ctrl+Shift+p 第二步：输入sftp，回车。注意要选择名字为sftp的，这里因为我安装过了所以搜不到！ 等待安装完成后进行下一步！第三步：配置插件参数 第四步：测试 到这里自动上传的功能就已经完成了，如果有遇到问题请在下面留言或发邮件，我会尽力帮你解答！","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"http://www.daichongweb.com/tags/tool/"}]},{"title":"微信公众号支付回调中发送模板消息的问题以及如何实现发送模板消息","slug":"微信公众号支付回调中发送模板消息的问题以及如何实现发送模板消息","date":"2018-07-21T06:01:25.000Z","updated":"2021-09-03T05:56:57.977Z","comments":true,"path":"微信公众号支付回调中发送模板消息的问题以及如何实现发送模板消息/","link":"","permalink":"http://www.daichongweb.com/微信公众号支付回调中发送模板消息的问题以及如何实现发送模板消息/","excerpt":"最近在做一个微信上的会员系统，涉及到微信支付回调中发送模板消息的问题。从来不喜欢看微信文档的我遇到了非常多的坑，最终还是填平了，希望大家再看了我这篇文章之后能少走些弯路吧！ 下面为大家贴出代码：支付回调12345678//调用模板消息user_pay(100,$userid,$openid,'pay_success',$integral.'元',$balance.'元');//向微信发送支付成功$textTpl=\"&lt;xml&gt;&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;&lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;&lt;/xml&gt;\";echo $textTpl;","text":"最近在做一个微信上的会员系统，涉及到微信支付回调中发送模板消息的问题。从来不喜欢看微信文档的我遇到了非常多的坑，最终还是填平了，希望大家再看了我这篇文章之后能少走些弯路吧！ 下面为大家贴出代码：支付回调12345678//调用模板消息user_pay(100,$userid,$openid,'pay_success',$integral.'元',$balance.'元');//向微信发送支付成功$textTpl=\"&lt;xml&gt;&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;&lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;&lt;/xml&gt;\";echo $textTpl;模板消息12345678910111213141516171819202122232425262728293031323334353637//获取access_token$access_token=access_tokens($appid,$appsecret,$mulu);//点击模板的跳转地址$url=$a['titleurl'].\"?action=my\";//获取通知模板Id$mb = $mbID;//充值成功通知if($type=='pay_success')&#123; $name = '充值成功！'; $time = date(\"Y-m-d H:i:s\"); $remark = \"恭喜您充值成功了！您可以前往个人中心查看账户余额以及升级方式,感谢您的支持！\"; //模板消息 $template=array( 'touser'=&gt;$openid, 'template_id'=&gt;$mb, 'url'=&gt;$url, 'topcolor'=&gt;\"#7B68EE\", 'data'=&gt;array( 'first'=&gt;array('value'=&gt;urlencode($name),'color'=&gt;\"#ff0000\"), 'keyword1'=&gt;array('value'=&gt;urlencode($userid),'color'=&gt;'#0000FE'), 'keyword2'=&gt;array('value'=&gt;urlencode($price),'color'=&gt;'#000000'), 'keyword3'=&gt;array('value'=&gt;urlencode($balance),'color'=&gt;'#000000'), 'keyword4'=&gt;array('value'=&gt;urlencode($time),'color'=&gt;'#000000'), 'remark'=&gt;array('value'=&gt;urlencode($remark),'color'=&gt;'#008000'), ) );&#125;$json_template=json_encode($template);$url=\"https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=\".$access_token;$res=http_request($url,urldecode($json_template));$res = json_decode($res,true);if($res['errcode']==0)&#123; return 1;&#125;else&#123; return 0;&#125;微信发送模板消息成功之后会回调你配置的消息地址注意在你配置的消息回调地址的方法中找到微信所回调的代码不能用exit或die来结束代码，支付回调将无法输出支付成功！","categories":[],"tags":[{"name":"微信支付","slug":"微信支付","permalink":"http://www.daichongweb.com/tags/微信支付/"}]},{"title":"php实现数据导出excel表格","slug":"php实现数据导出excel表格","date":"2018-07-16T08:03:55.000Z","updated":"2021-09-03T05:56:57.955Z","comments":true,"path":"php实现数据导出excel表格/","link":"","permalink":"http://www.daichongweb.com/php实现数据导出excel表格/","excerpt":"今天的博客内容是php实现导出excel,大家都知道实现php导出excel有很多种方法，最方便的是phpexcel这个插件，但是在处理海量数据的时候就会出现非常非常缓慢的情况。而且用这个插件要求的php版本是5.6以上，很不巧，我的php版本是5.4。用不了这个插件，只能另寻他法了！ 刚开始的使用是使用前端的table导出,感觉不是很好用，代码量太大，不方便。 后来又尝试了几种方法，最后选择了一种最简单，最有效，代码量最少的方法！","text":"今天的博客内容是php实现导出excel,大家都知道实现php导出excel有很多种方法，最方便的是phpexcel这个插件，但是在处理海量数据的时候就会出现非常非常缓慢的情况。而且用这个插件要求的php版本是5.6以上，很不巧，我的php版本是5.4。用不了这个插件，只能另寻他法了！ 刚开始的使用是使用前端的table导出,感觉不是很好用，代码量太大，不方便。 后来又尝试了几种方法，最后选择了一种最简单，最有效，代码量最少的方法！代码123456789101112131415161718&lt;?phprequire_once('./db.php');class index extends Db&#123; public function index() &#123; $data = Db::get_all(\"select userid from order\"); header(\"Content-type:application/vnd.ms-excel\");//设置导出格式 header(\"Content-Disposition:filename=导出.xls\");//设置导出文件名称 header(\"Cache-Control: max-age=0\");//数据不经过缓存，每次查询数据库 $strexport=\"Userid\\r\"; foreach ($data as $row)&#123; $strexport.= $row['userid'].\"\\r\"; &#125; $strexport = iconv('UTF-8',\"GB2312//IGNORE\",$strexport); exit($strexport); &#125;&#125;$obj = new index; 这段代码只是实现最简单的导出，具体的优化就需要大家去研究了！","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"php转义html实体","slug":"php转义html实体","date":"2018-07-11T09:35:45.000Z","updated":"2021-09-03T05:56:57.964Z","comments":true,"path":"php转义html实体/","link":"","permalink":"http://www.daichongweb.com/php转义html实体/","excerpt":"","text":"经常使用各种编辑器的小伙伴们都会遇到，在复制一些带有样式文字到编辑器然后保存到数据库里之后一些特殊的符号被转义成了html实体。 例如：大于号和小于号，通过编辑器和框架的过滤和处理存到数据库的是&amp;gt和&lt; 然后在前端把数据输出到页面上之后还是数据库里的原文，并没有转义成正常的符号。 那么就需要用到这个php函数了： 转义函数官方文档1htmlspecialchars_decode() 在我使用之后发现他不仅能解决这些符号的问题，其他html标签的问题在转义后也能正常使用。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"微信支付异步回调验证订单真实性","slug":"微信支付异步回调验证订单真实性","date":"2018-07-07T12:48:11.000Z","updated":"2021-09-03T05:56:57.977Z","comments":true,"path":"微信支付异步回调验证订单真实性/","link":"","permalink":"http://www.daichongweb.com/微信支付异步回调验证订单真实性/","excerpt":"最近在做一个充值功能，因为是微网站并且是在微信公众号内，所以选择了微信公众号支付。做过微信支付的小伙伴都知道微信支付的模式分为三种： 第一种：普通商户 第二种：服务商 第三种：银行服务 三种支付模式有很明显的不同，第一种就是最常见的普通微信公众号支付，支付需要微信公众号的appid appkey mc_id mc_key 四个支付参数。而这四个参数都是属于单独的微信支付参数。","text":"最近在做一个充值功能，因为是微网站并且是在微信公众号内，所以选择了微信公众号支付。做过微信支付的小伙伴都知道微信支付的模式分为三种： 第一种：普通商户 第二种：服务商 第三种：银行服务 三种支付模式有很明显的不同，第一种就是最常见的普通微信公众号支付，支付需要微信公众号的appid appkey mc_id mc_key 四个支付参数。而这四个参数都是属于单独的微信支付参数。第二种是服务商模式，首先要有一个服务商的支付平台，然后通过这个服务商支付平台申请子商户平台。那么支付的时候同样的四个支付参数就要从服务商和子商户获得了，并不是单独的一个公众号里的参数。具体大家可以看微信的文档。 第三种暂时没做过。 周所众知微信支付异步回调验证订单真实性是非常重要的，如果不做验证，在有人知道你的微信支付回调地址后就能直接请求你的支付回调地址，模仿微信支付回调达到不支付金额就能充值、购买商品等操作！所以验证订单的真实性是每个程序员必须要做的！ 那么具体的验证步骤有哪些呢？ 第一步：接收微信返回的参数。第二步：处理参数。第三步：使用ksort排序参数，ASCII码从小到大排序.第四步：在参数后面连接上(商户秘钥设置路径：微信商户平台(pay.weixin.qq.com)–&gt;账户设置–&gt;API安全–&gt;密钥设置)。第五步：加密生成签名。第六步：对比加密后的签名。 具体的步骤可以在微信支付开发文档中查看详细的签名生成和对比的步骤！ 下面就是我根据微信文档写的代码：[生成签名及对比] []1234567891011121314151617181920212223242526272829$postobj = $GLOBALS['HTTP_RAW_POST_DATA'];//第一种方式$postobj = file_get_contents(\"php://input\");//第二种方式$postObj = (array)simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);//转化xml数据为数组 $result_code = $postObj['result_code'];//微信返回的参数 if($result_code==\"SUCCESS\")&#123;//参数值为SUCCESS时说明支付成功 $total_fee = $postObj['total_fee']; //签名算法 Start ksort($postObj);//排序参数 $buff = \"\"; foreach ($postObj as $k =&gt; $v)//处理参数按照key=&gt;value的形式组合成字符串 &#123; if($k != \"sign\" &amp;&amp; $v != \"\" &amp;&amp; !is_array($v))&#123;//去掉参数中的sign（微信返回的签名） $buff .= $k . \"=\" . $v . \"&amp;\"; &#125; &#125; $buff = trim($buff, \"&amp;\");//去除末尾的&amp;的符号 $buff = $buff.'&amp;key=秘钥';//连接上商户支付秘钥 $signA = strtoupper(MD5($buff));//MD5加密并转为小写 &#125; if($postobj['sign']==$signA &amp;&amp; $total_fee==真实的支付金额)&#123; //订单真实 //逻辑处理 &#125;else&#123; //签名错误或支付错误 echo '&lt;xml&gt; &lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;//success成功 fail失败 &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt; &lt;/xml&gt;';//返回微信消息否则微信会一直请求你的异步回调地址 &#125; 注意：以上是针对服务商支付的签名对比方法，普通商户的方法基本上和这个是一致的（普通商户可能不需要去除sign）。","categories":[],"tags":[{"name":"微信支付","slug":"微信支付","permalink":"http://www.daichongweb.com/tags/微信支付/"}]},{"title":"php 单例模式连接数据库PDO","slug":"php单例模式连接数据库PDO","date":"2018-06-10T08:36:28.000Z","updated":"2021-09-03T05:56:57.954Z","comments":true,"path":"php单例模式连接数据库PDO/","link":"","permalink":"http://www.daichongweb.com/php单例模式连接数据库PDO/","excerpt":"本篇介绍一下php的单例模式以及PDO连接数据库的方法。 说到’单例模式‘php基础比较扎实的童鞋肯定不陌生，但像本人这样的程序猿基础不是很好的可能只是有些印象而已。 那么’单例模式‘到底是什么呢？ 他其实是php框架底层比较常用的一种设计模式，例如’工厂模式‘、’注册树模式‘、’策略模式‘以及’观察者模式‘等等，都是php各大框架底层架构的核心所在！ 所谓的’单例模式‘说白了其实就是’三私有，一公有‘。 ’三私有‘：一个私有变量作为实例化对象存储，两个私有方法’clone‘防止克隆对象以及’construct‘。 ’一公有‘：一个共有的方法用来检测和实例化类。","text":"本篇介绍一下php的单例模式以及PDO连接数据库的方法。 说到’单例模式‘php基础比较扎实的童鞋肯定不陌生，但像本人这样的程序猿基础不是很好的可能只是有些印象而已。 那么’单例模式‘到底是什么呢？ 他其实是php框架底层比较常用的一种设计模式，例如’工厂模式‘、’注册树模式‘、’策略模式‘以及’观察者模式‘等等，都是php各大框架底层架构的核心所在！ 所谓的’单例模式‘说白了其实就是’三私有，一公有‘。 ’三私有‘：一个私有变量作为实例化对象存储，两个私有方法’clone‘防止克隆对象以及’construct‘。 ’一公有‘：一个共有的方法用来检测和实例化类。下面是代码：[单例类]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php header(\"Content-Type: text/html;charset=utf-8\"); //单例class Uni&#123; //创建静态私有的变量保存该类对象 private static $instance; //防止直接创建对象 private function __construct()&#123; &#125; //防止克隆对象 private function __clone()&#123; &#125; public static function getInstance()&#123; //判断$instance是否是Uni的对象 //没有则创建 if (!self::$instance) &#123; //实例化本类对象 传入参数,实例化类会执行构造函数 self::$instance = new PDO('mysql:host=127.0.0.1;dbname=test', 'root', 'root'); &#125; return self::$instance; &#125; //查询多条数据 public static function get_all($sql,$type=1)&#123; try &#123; if($type==1)&#123; //缓冲查询 $data = self::getInstance()-&gt;query($sql)-&gt;fetchAll(PDO::FETCH_ASSOC); &#125;else&#123; //非缓冲查询 $uresult = self::getInstance()-&gt;query($sql); if ($uresult) &#123; while ($data[] = $uresult-&gt;fetch(PDO::FETCH_ASSOC)) &#123;&#125; &#125; &#125; return $data; &#125; catch (Exception $e) &#123; return '查询错误'.$e; &#125; &#125; //查询单条数据 public static function get_one($sql)&#123; try &#123; $data = self::getInstance()-&gt;query($sql)-&gt;fetch(PDO::FETCH_ASSOC); return $data; &#125; catch (Exception $e) &#123; return '查询错误'.$e; &#125; &#125; //查询单个字段 public static function get_field($sql,$field)&#123; try &#123; $data = self::getInstance()-&gt;query($sql)-&gt;fetch(PDO::FETCH_ASSOC); return $data[$field]; &#125; catch (Exception $e) &#123; return '查询错误'.$e; &#125; &#125; &#125; 看到这里有的童鞋可能还会有些疑问：”这些代码到底是能起到什么作用呢？“，下面就为大家演示一下这个单例类到底是干什么用的。[演示代码]12345678910public static function getInstance()&#123; //判断$instance是否是Uni的对象 //没有则创建 if (!self::$instance) &#123; // 这里在往上看到有的人是用 instanceof self 来判断的，大同小异。 echo 1; //实例化本类对象 传入参数,实例化类会执行构造函数 self::$instance = new PDO('mysql:host=127.0.0.1;dbname=test', 'root', 'root'); &#125; return self::$instance; &#125; 我们再连接数据库这里输出一个 1，然后调用一下这个方法： [调用方法]12Uni::getInstance();//1 我们会发现页面上输出了一个 ’1‘，这是没问题的。 接下来我们写一个循环： [循环调用]1234for ($i=0; $i &lt;10; $i++) &#123; Uni::getInstance(); &#125;//1 到这我们会发现页面上输出的还是一个 ’1‘，说明我们多次调用这个类，但只连接了一次数据库。如果没有这个单例类，我们可能每次的查询都去连接数据库，过多的连接会导致数据库崩溃。 所以这个单例模式还是很重要的。 大家学到了吗？","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"mysql 删除表中重复的数据","slug":"mysql删除表中重复的数据","date":"2018-06-06T13:21:27.000Z","updated":"2021-09-03T05:56:57.933Z","comments":true,"path":"mysql删除表中重复的数据/","link":"","permalink":"http://www.daichongweb.com/mysql删除表中重复的数据/","excerpt":"sql删除数据库重复的数据 今天在工作中遇到了一个注册绑定微信UID的问题。按正常逻辑来说，一个手机号只能绑定一个UId，但问题总是会只有你想不到没有你做不到，有个客户居然用一个手机号绑定了几百个手机号，具体是为了干什么就不说了。有一个人能想到这样的方法，就会有第二个人能想到，之后就不用说了越来越多。仅仅几天数据库里的数据已经几万条了，慢慢的我意识到了这样下去肯定是不行的，必须想办法解决。刚开始是手动删除重复的数据，但是太多了，手动删简直是没法弄，不删还不行，给字段加唯一索引必须要把重复的数据删掉.","text":"sql删除数据库重复的数据 今天在工作中遇到了一个注册绑定微信UID的问题。按正常逻辑来说，一个手机号只能绑定一个UId，但问题总是会只有你想不到没有你做不到，有个客户居然用一个手机号绑定了几百个手机号，具体是为了干什么就不说了。有一个人能想到这样的方法，就会有第二个人能想到，之后就不用说了越来越多。仅仅几天数据库里的数据已经几万条了，慢慢的我意识到了这样下去肯定是不行的，必须想办法解决。刚开始是手动删除重复的数据，但是太多了，手动删简直是没法弄，不删还不行，给字段加唯一索引必须要把重复的数据删掉.[sql]1234567891011121314151617181920212223242526delete from [table_name] where [primary key] in (select [primary key] from (select [primary key]FROM [table_name]WHERE [重复的字段名] IN ( SELECT [primary key] FROM [table_name] GROUP BY [重复的字段名] HAVING count([重复的字段名]) &gt; 1 )AND [primary key] NOT IN ( SELECT min([primary key]) FROM [table_name] GROUP BY [重复的字段名] HAVING count([重复的字段名]) &gt; 1))a)这段sql不仅解决了我的燃眉之急，并且还帮我保留了重复数据中的一条最老的数据！ 虽然sql写的很完美但是也要经过实践才能是不是正确的！1SELECT * FROM [table_name] group by [重复的字段名] HAVING count(*)&gt;1查询条数为0，sql正确无误，漂亮！","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.daichongweb.com/tags/mysql/"}]},{"title":"php将指定文字替换为相同数量的*号","slug":"php将指定文字替换为相同数量的-号","date":"2018-06-04T05:23:50.000Z","updated":"2021-09-03T05:56:57.955Z","comments":true,"path":"php将指定文字替换为相同数量的-号/","link":"","permalink":"http://www.daichongweb.com/php将指定文字替换为相同数量的-号/","excerpt":"","text":"替换文字为星号的功能经常会遇到，比如关键词过滤，聊天内容过滤等，话不多说直接上代码！ [实现代码]1234567891011121314$text = \"苏菲的世界安防科技按时付款链接萨达哈垃圾卡刷卡费SAP发生破房间爱上；靠谱积分卡普斯安徽交付恐怕是电话费破ID卡手IP卡\";// 回调函数function next_year($matches)&#123; $len = mb_strlen($matches[0],'UTF8'); $res = ''; for($i=1;$i&lt;=$len;$i++)&#123; $res.='*'; &#125; return $res;&#125;$arr = array('链接','卡');$preg_str = implode('|',$arr);echo preg_replace_callback(\"/($preg_str)/\",\"next_year\",$text);","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"php 数组分组 二维数组中，将某个键值相同的合并到一个数组中","slug":"php数组分组-二维数组中，将某个键值相同的合并到一个数组中","date":"2018-06-04T05:09:35.000Z","updated":"2021-09-03T05:56:57.960Z","comments":true,"path":"php数组分组-二维数组中，将某个键值相同的合并到一个数组中/","link":"","permalink":"http://www.daichongweb.com/php数组分组-二维数组中，将某个键值相同的合并到一个数组中/","excerpt":"原数据12345678910111213141516171819$arr = array( 0 =&gt; array ( 'initial' =&gt; 'A', 'typename' =&gt; '奥迪' ), 1 =&gt; array ( 'initial' =&gt; 'F', 'typename' =&gt;'F1' ), 2 =&gt; array ( 'initial' =&gt; 'F', 'typename' =&gt; 'F2' ));","text":"原数据12345678910111213141516171819$arr = array( 0 =&gt; array ( 'initial' =&gt; 'A', 'typename' =&gt; '奥迪' ), 1 =&gt; array ( 'initial' =&gt; 'F', 'typename' =&gt;'F1' ), 2 =&gt; array ( 'initial' =&gt; 'F', 'typename' =&gt; 'F2' )); [合并代码]1234$result = array();foreach($arr as $k=&gt;$v)&#123; $result[$v['initial']][] = $v;&#125; [分组后的数组]1234567891011121314151617181920212223242526272829Array( [A] =&gt; Array ( [0] =&gt; Array ( [initial] =&gt; A [typename] =&gt; 奥迪 ) ) [F] =&gt; Array ( [0] =&gt; Array ( [initial] =&gt; F [typename] =&gt; F1 ) [1] =&gt; Array ( [initial] =&gt; F [typename] =&gt; F2 ) ))","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"}]},{"title":"linux重装系统后ssh连接认证的问题","slug":"Linux重装系统后ssh连接认证的问题","date":"2018-06-04T05:00:09.000Z","updated":"2021-09-03T05:56:57.876Z","comments":true,"path":"Linux重装系统后ssh连接认证的问题/","link":"","permalink":"http://www.daichongweb.com/Linux重装系统后ssh连接认证的问题/","excerpt":"","text":"[命令行报错提示]12345678910111213141516171819202122232425@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:Qv4XPuXFuO1G8s0teCXRANvVnZy1jjIFKkp8yfJgLeA.Please contact your system administrator.Add correct host key in /c/Users/Administrator/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /c/Users/Administrator/.ssh/known_hosts:3ECDSA host key for 58.87.72.33 has changed and you have requested strict checking.Host key verification failed. 对于一个小白来说，这个是完全看不懂的，下面就告诉大家如何解决这个问题。 首先用ssh第一次连接sever,sever会生成一个公钥和一个私钥，私钥存在连接方的本地，系统重装后sever会重新生成一个公钥，然后连接方的私钥已经和sever的公钥不匹配，导致报错无法登录。 解决方法： ssh-keygen -R xx.xx.xx.xx 后面跟ip即可删除指定服务器的公钥文件，再次连接时重新生成，并覆盖掉连接方的私钥。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.daichongweb.com/tags/linux/"}]},{"title":"liunx重装系统后ssh连接认证的问题","slug":"liunx重装系统后ssh连接认证的问题","date":"2018-06-04T05:00:09.000Z","updated":"2021-09-03T05:56:57.930Z","comments":true,"path":"liunx重装系统后ssh连接认证的问题/","link":"","permalink":"http://www.daichongweb.com/liunx重装系统后ssh连接认证的问题/","excerpt":"","text":"[命令行报错提示]12345678910111213141516171819202122232425@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:Qv4XPuXFuO1G8s0teCXRANvVnZy1jjIFKkp8yfJgLeA.Please contact your system administrator.Add correct host key in /c/Users/Administrator/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /c/Users/Administrator/.ssh/known_hosts:3ECDSA host key for 58.87.72.33 has changed and you have requested strict checking.Host key verification failed. 对于一个小白来说，这个是完全看不懂的，下面就告诉大家如何解决这个问题。 首先用ssh第一次连接sever,sever会生成一个公钥和一个私钥，私钥存在连接方的本地，系统重装后sever会重新生成一个公钥，然后连接方的私钥已经和sever的公钥不匹配，导致报错无法登录。 解决方法： ssh-keygen -R xx.xx.xx.xx 后面跟ip即可删除指定服务器的公钥文件，再次连接时重新生成，并覆盖掉连接方的私钥。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daichongweb.com/tags/Linux/"}]},{"title":"jquery简单实现图片懒加载","slug":"jquery简单实现图片懒加载","date":"2018-06-01T03:04:11.000Z","updated":"2021-09-03T05:56:57.929Z","comments":true,"path":"jquery简单实现图片懒加载/","link":"","permalink":"http://www.daichongweb.com/jquery简单实现图片懒加载/","excerpt":"最近突发奇想，想优化web网站。我是一个后端程序员，但对js很感兴趣，之前总听说图片懒加载可以优化网站，本来以为是很难得技术，今天亲手试了一下才发现是如此简单。下面为大家奉上我的代码！","text":"最近突发奇想，想优化web网站。我是一个后端程序员，但对js很感兴趣，之前总听说图片懒加载可以优化网站，本来以为是很难得技术，今天亲手试了一下才发现是如此简单。下面为大家奉上我的代码！1alert('Hello Welcome to DaiChong.Blog!'); [首先是html部分]123456789101112131415161718&lt;style&gt;*&#123; padding:0; margin:0; list-style:none;&#125;img&#123; height:200px; width:100%;&#125;&lt;/style&gt;&lt;ul&gt; &lt;li&gt;&lt;img src='1.png'&gt;&lt;/li&gt; &lt;li&gt;&lt;img src='1.png'&gt;&lt;/li&gt; &lt;li&gt;&lt;img src='1.png'&gt;&lt;/li&gt; &lt;li&gt;&lt;img src='1.png'&gt;&lt;/li&gt; &lt;li&gt;&lt;img src='1.png'&gt;&lt;/li&gt;&lt;/ul&gt; [juqery部分]12345678910111213141516171819202122232425262728&lt;script&gt; $(function()&#123; //代替数据 var arr = ['./1.jpg','./01.png','./02.png','./03.png','./03(1).png','./客房1.png','./客房2.png']; var str = \"\"; $.each(arr,function (k,v) &#123; str+='&lt;li&gt;&lt;img data-src=\"'+v+'\"&gt;&lt;/li&gt;'; &#125;) $(\"ul\").html(str); //初始化一次 load_img(); &#125;) $(window).scroll(function()&#123; load_img(); &#125;) function load_img()&#123; //可视区域的高度 var view_height = $(window).height(); //滚动条的高度 var scroll_top = $(window).scrollTop(); $('ul li img').each(function(k,v)&#123; var top = $(v).offset().top-scroll_top; if(top&lt;view_height)&#123; $(v).attr('src',$(v).attr('data-src')); &#125; &#125;) &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://www.daichongweb.com/tags/jquery/"}]}],"categories":[{"name":"liunx","slug":"liunx","permalink":"http://www.daichongweb.com/categories/liunx/"},{"name":"hexo","slug":"hexo","permalink":"http://www.daichongweb.com/categories/hexo/"},{"name":"php扩展类","slug":"php扩展类","permalink":"http://www.daichongweb.com/categories/php扩展类/"},{"name":"开发工具","slug":"开发工具","permalink":"http://www.daichongweb.com/categories/开发工具/"},{"name":"mysql","slug":"mysql","permalink":"http://www.daichongweb.com/categories/mysql/"},{"name":"php框架","slug":"php框架","permalink":"http://www.daichongweb.com/categories/php框架/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://www.daichongweb.com/tags/微信小程序/"},{"name":"微信支付","slug":"微信支付","permalink":"http://www.daichongweb.com/tags/微信支付/"},{"name":"开发工具","slug":"开发工具","permalink":"http://www.daichongweb.com/tags/开发工具/"},{"name":"java","slug":"java","permalink":"http://www.daichongweb.com/tags/java/"},{"name":"node","slug":"node","permalink":"http://www.daichongweb.com/tags/node/"},{"name":"php","slug":"php","permalink":"http://www.daichongweb.com/tags/php/"},{"name":"小程序支付","slug":"小程序支付","permalink":"http://www.daichongweb.com/tags/小程序支付/"},{"name":"php扩展类","slug":"php扩展类","permalink":"http://www.daichongweb.com/tags/php扩展类/"},{"name":"nginx","slug":"nginx","permalink":"http://www.daichongweb.com/tags/nginx/"},{"name":"mysql","slug":"mysql","permalink":"http://www.daichongweb.com/tags/mysql/"},{"name":"vue","slug":"vue","permalink":"http://www.daichongweb.com/tags/vue/"},{"name":"laravel","slug":"laravel","permalink":"http://www.daichongweb.com/tags/laravel/"},{"name":"架构","slug":"架构","permalink":"http://www.daichongweb.com/tags/架构/"},{"name":"测试","slug":"测试","permalink":"http://www.daichongweb.com/tags/测试/"},{"name":"redis","slug":"redis","permalink":"http://www.daichongweb.com/tags/redis/"},{"name":"linux","slug":"linux","permalink":"http://www.daichongweb.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://www.daichongweb.com/tags/git/"},{"name":"jquery","slug":"jquery","permalink":"http://www.daichongweb.com/tags/jquery/"},{"name":"walle","slug":"walle","permalink":"http://www.daichongweb.com/tags/walle/"},{"name":"hexo","slug":"hexo","permalink":"http://www.daichongweb.com/tags/hexo/"},{"name":"composer","slug":"composer","permalink":"http://www.daichongweb.com/tags/composer/"},{"name":"sublime","slug":"sublime","permalink":"http://www.daichongweb.com/tags/sublime/"},{"name":"phpExcel","slug":"phpExcel","permalink":"http://www.daichongweb.com/tags/phpExcel/"},{"name":"tp5","slug":"tp5","permalink":"http://www.daichongweb.com/tags/tp5/"},{"name":"js","slug":"js","permalink":"http://www.daichongweb.com/tags/js/"},{"name":"浏览器","slug":"浏览器","permalink":"http://www.daichongweb.com/tags/浏览器/"},{"name":"tool","slug":"tool","permalink":"http://www.daichongweb.com/tags/tool/"},{"name":"Linux","slug":"Linux","permalink":"http://www.daichongweb.com/tags/Linux/"}]}